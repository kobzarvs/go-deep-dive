# Interface Internals

Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑÑ‹ Ğ² Go â€” ÑÑ‚Ğ¾ Ğ½Ğµ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ñ‹. Ğ­Ñ‚Ğ¾ ÑĞ»Ğ¾Ğ¶Ğ½Ñ‹Ğµ runtime-ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ñ vtable-Ğ¿Ğ¾Ğ´Ğ¾Ğ±Ğ½Ñ‹Ğ¼ dispatch, ĞºĞµÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ itab Ğ¸ ÑƒĞ¼Ğ½Ñ‹Ğ¼ boxing. Ğ’ ÑÑ‚Ğ¾Ğ¹ ÑÑ‚Ğ°Ñ‚ÑŒĞµ Ñ€Ğ°Ğ·Ğ±ĞµÑ€Ñ‘Ğ¼, ĞºĞ°Ğº Ğ¸Ğ¼ĞµĞ½Ğ½Ğ¾ ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€ Ğ¸ runtime Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ÑÑÑ‚ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑÑ‹ Ğ² Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸.

## TL;DR

| Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° | Ğ Ğ°Ğ·Ğ¼ĞµÑ€ | ĞĞ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ |
|-----------|--------|------------|
| **iface** | 16 Ğ±Ğ°Ğ¹Ñ‚ (2 ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ñ, 64-bit) | Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ñ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ°Ğ¼Ğ¸ |
| **eface** | 16 Ğ±Ğ°Ğ¹Ñ‚ (2 ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ñ, 64-bit) | ĞŸÑƒÑÑ‚Ğ¾Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ `any` / `interface{}` |
| **itab** | 32+ Ğ±Ğ°Ğ¹Ñ‚Ğ° | Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² + Ğ¼ĞµÑ‚Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ‚Ğ¸Ğ¿Ğ¾Ğ² |
| **_type** | ~48 Ğ±Ğ°Ğ¹Ñ‚ (Ğ¿Ğ¾Ñ€ÑĞ´Ğ¾Ğº, 64-bit) | Type descriptor (Ñ€Ğ°Ğ·Ğ¼ĞµÑ€, hash, Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹) |

| ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ | Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ |
|----------|-----------|
| Interface assignment | O(1), Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ñ Ğ´Ğ»Ñ boxing |
| Method dispatch | Indirect call Ñ‡ĞµÑ€ĞµĞ· itab.fun[] (Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾ ĞµĞ´Ğ¸Ğ½Ğ¸Ñ†Ñ‹ ns) |
| Type assertion (Ğ¿Ğ¾Ğ¿Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ² ĞºĞµÑˆ) | O(1) Ğ² ÑÑ€ĞµĞ´Ğ½ĞµĞ¼, Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ñ itab |
| Type assertion (Ğ¿Ñ€Ğ¾Ğ¼Ğ°Ñ… ĞºĞµÑˆĞ°) | O(1) Ğ² ÑÑ€ĞµĞ´Ğ½ĞµĞ¼, O(n) Ğ² Ñ…ÑƒĞ´ÑˆĞµĞ¼ ÑĞ»ÑƒÑ‡Ğ°Ğµ |

## iface vs eface

Go Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ Ğ´Ğ²Ğµ Ñ€Ğ°Ğ·Ğ½Ñ‹Ğµ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ´Ğ»Ñ Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ¾Ğ²:

```
iface â€” Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ñ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ°Ğ¼Ğ¸          eface â€” Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ (any)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  tab  *itab          â”‚â”€â”€â”€â”€â”€â”€â”       â”‚  _type *_type        â”‚â”€â”€â”€â”€â”€â”€â”
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”‚       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”‚
â”‚  data unsafe.Pointer â”‚â”€â”€â”   â”‚       â”‚  data  unsafe.Pointerâ”‚â”€â”€â”   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
                          â”‚   â”‚                                 â”‚   â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
       â”‚                      â”‚            â”‚                        â”‚
       â–¼                      â–¼            â–¼                        â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ value â”‚           â”‚   itab    â”‚   â”‚ value â”‚            â”‚   _type   â”‚
   â”‚ (T)   â”‚           â”‚  (Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹) â”‚   â”‚ (T)   â”‚            â”‚(type info)â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ Ğ´Ğ²Ğµ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹?**

- `iface` Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ `*itab` â€” Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² Ğ´Ğ»Ñ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ¹ Ğ¿Ğ°Ñ€Ñ‹ (interface type, concrete type)
- `eface` Ğ½Ğµ Ğ¸Ğ¼ĞµĞµÑ‚ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ², Ğ¿Ğ¾ÑÑ‚Ğ¾Ğ¼Ñƒ Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ `*_type` â€” Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ñ‚Ğ¸Ğ¿Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
- ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ: Ğ´Ğ»Ñ `any` Ğ½Ğµ Ğ½ÑƒĞ¶Ğ½Ğ¾ ÑĞ¾Ğ·Ğ´Ğ°Ğ²Ğ°Ñ‚ÑŒ itab

```go
// runtime/runtime2.go

// Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ñ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ°Ğ¼Ğ¸: io.Reader, fmt.Stringer, etc.
type iface struct {
    tab  *itab
    data unsafe.Pointer
}

// ĞŸÑƒÑÑ‚Ğ¾Ğ¹ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ: any, interface{}
type eface struct {
    _type *_type
    data  unsafe.Pointer
}
```

### ĞšĞ¾Ğ³Ğ´Ğ° ĞºĞ°ĞºĞ°Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ

```go
var w io.Writer = os.Stdout  // iface: ĞµÑÑ‚ÑŒ Ğ¼ĞµÑ‚Ğ¾Ğ´ Write
var r io.Reader = f          // iface: ĞµÑÑ‚ÑŒ Ğ¼ĞµÑ‚Ğ¾Ğ´ Read
var s fmt.Stringer = t       // iface: ĞµÑÑ‚ÑŒ Ğ¼ĞµÑ‚Ğ¾Ğ´ String

var x any = 42               // eface: Ğ½ĞµÑ‚ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ²
var y interface{} = "hello"  // eface: Ğ½ĞµÑ‚ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ²
```

Ğ Ğ°Ğ·Ğ½Ğ¸Ñ†Ğ° Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ÑÑ **Ñ‚Ğ¸Ğ¿Ğ¾Ğ¼ ÑĞ»ĞµĞ²Ğ°**. ĞĞ´Ğ¸Ğ½ Ğ¸ Ñ‚Ğ¾Ñ‚ Ğ¶Ğµ Ğ¾Ğ±ÑŠĞµĞºÑ‚ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ ÑƒĞ¿Ğ°ĞºĞ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾-Ñ€Ğ°Ğ·Ğ½Ğ¾Ğ¼Ñƒ:

```go
var buf bytes.Buffer

var a any = &buf      // eface: Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ _type + data
var b io.Writer = &buf // iface: tab + data
```

`iface` Ğ½ÑƒĞ¶ĞµĞ½ Ğ´Ğ»Ñ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² (Ğ°Ğ´Ñ€ĞµÑĞ° Ğ»ĞµĞ¶Ğ°Ñ‚ Ğ² itab), `eface` â€” Ğ±ĞµĞ· Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ².

## iface Memory Layout

Ğ Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ğ¼ Ğ¿Ğ¾Ğ´Ñ€Ğ¾Ğ±Ğ½ĞµĞµ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ `iface`:

```
Stack                        Heap / Static
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     var w Writer    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚ tab  *itab    â”‚â”€â”€â”¼â”€â”€â”€â”€â”€â–¶â”‚ itab                    â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ data *T       â”‚â”€â”€â”¼â”€â”€â”   â”‚ â”‚ inter *interfacetypeâ”‚ â”‚â”€â”€â”€â–¶ Writer type info
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚   â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚ â”‚ _type *_type        â”‚ â”‚â”€â”€â”€â–¶ *os.File type info
                         â”‚   â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
                         â”‚   â”‚ â”‚ hash  uint32        â”‚ â”‚
                         â”‚   â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
                         â”‚   â”‚ â”‚ fun   [1]uintptr    â”‚ â”‚â”€â”€â”€â–¶ (*os.File).Write
                         â”‚   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                         â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â””â”€â”€â–¶â”‚ *os.File value         â”‚
                             â”‚ (ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ)  â”‚
                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ĞŸĞ¾Ğ»Ğµ data

`data` ÑƒĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ½Ğ° ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ. Ğ’Ğ°Ğ¶Ğ½Ñ‹Ğµ Ğ½ÑĞ°Ğ½ÑÑ‹:

```go
// 1. Ğ£ĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ â€” data ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ ÑĞ°Ğ¼ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ (Ğ±ĞµĞ· Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ğ¸)
var w io.Writer = &Buffer{}  // data = Ğ°Ğ´Ñ€ĞµÑ Buffer Ğ½Ğ° heap

// 2. ĞœĞ°Ğ»ĞµĞ½ÑŒĞºĞ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ (â‰¤ pointer size) â€” Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ inline
var s fmt.Stringer = mySmallStruct{}  // data Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ ÑĞ°Ğ¼Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ

// 3. Ğ‘Ğ¾Ğ»ÑŒÑˆĞ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ â€” Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ñ Ğ½Ğ° heap
var s fmt.Stringer = myBigStruct{}  // data = ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğ° ĞºĞ¾Ğ¿Ğ¸Ñ Ğ² heap
```

Ğ’Ğ°Ğ¶Ğ½Ğ¾: Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ **Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ ĞºĞ¾Ğ¿Ğ¸Ñ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ**, Ğ° Ğ½Ğµ ÑÑÑ‹Ğ»ĞºÑƒ (ĞµÑĞ»Ğ¸ ÑÑ‚Ğ¾ Ğ½Ğµ pointer).

```go
type S struct{ n int }
s := S{n: 1}
var i any = s
s.n = 2
fmt.Println(i.(S).n) // 1: Ğ² Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞµ Ğ»ĞµĞ¶Ğ¸Ñ‚ ĞºĞ¾Ğ¿Ğ¸Ñ
```

ĞŸĞ¾ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ¿Ñ€Ğ¸ÑĞ²Ğ°Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ² Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ñ€Ğ¸Ğ²Ğ¾Ğ´Ğ¸Ñ‚ÑŒ Ğº Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ğ¸: Ğ½ÑƒĞ¶Ğ½Ğ° ĞºĞ¾Ğ¿Ğ¸Ñ.

## itab Deep Dive

`itab` â€” ĞºĞ»ÑÑ‡ĞµĞ²Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ method dispatch:

```go
// internal/abi/iface.go
type ITab struct {
    Inter *InterfaceType  // Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ°
    Type  *Type           // Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ñ‚Ğ¸Ğ¿Ğ°
    Hash  uint32          // ĞºĞ¾Ğ¿Ğ¸Ñ Type.Hash Ğ´Ğ»Ñ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾Ğ³Ğ¾ ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ñ
    _     [4]byte         // padding
    Fun   [1]uintptr      // variable-size array ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ½Ğ° Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹
}
```

### Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° itab Ğ² Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸

```
itab Ğ´Ğ»Ñ (io.Writer, *os.File)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Inter  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ interfacetype {                     â”‚
â”‚                       Type: _type Ğ´Ğ»Ñ io.Writer         â”‚
â”‚                       PkgPath: "io"                     â”‚
â”‚                       Methods: [{Name: "Write", ...}]   â”‚
â”‚                     }                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Type   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ _type {                             â”‚
â”‚                       Size: 8                           â”‚
â”‚                       Hash: 0x12345678                  â”‚
â”‚                       Kind: Ptr                         â”‚
â”‚                       ...                               â”‚
â”‚                     }                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Hash   = 0x12345678   (ĞºĞ¾Ğ¿Ğ¸Ñ Type.Hash)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Fun[0] = (*os.File).Write   â—€â”€â”€ Ğ¼ĞµÑ‚Ğ¾Ğ´ #0                â”‚
â”‚ Fun[1] = ...                    (ĞµÑĞ»Ğ¸ Ğ±Ñ‹ Ğ±Ñ‹Ğ»Ğ¸ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ)   â”‚
â”‚ ...                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Fun[] â€” Ğ¼Ğ°ÑÑĞ¸Ğ² ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ĞµĞ¹ Ğ½Ğ° Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹

Ğ Ğ°Ğ·Ğ¼ĞµÑ€ `Fun[]` Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ÑÑ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾Ğ¼ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² Ğ² Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞµ:

```go
// io.Writer Ğ¸Ğ¼ĞµĞµÑ‚ 1 Ğ¼ĞµÑ‚Ğ¾Ğ´ â†’ Fun[1]
type Writer interface {
    Write(p []byte) (n int, err error)
}

// io.ReadWriter Ğ¸Ğ¼ĞµĞµÑ‚ 2 Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ° â†’ Fun[2]
type ReadWriter interface {
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
}

// io.ReadWriteCloser Ğ¸Ğ¼ĞµĞµÑ‚ 3 Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ° â†’ Fun[3]
type ReadWriteCloser interface {
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
    Close() error
}
```

ĞšĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€ Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğµ `w.Write` Ğ·Ğ°Ñ€Ğ°Ğ½ĞµĞµ Ğ·Ğ½Ğ°ĞµÑ‚ Ğ¸Ğ½Ğ´ĞµĞºÑ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ° Ğ² Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞµ Ğ¸ Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚ Ğ¾Ğ±Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸Ğµ Ğº `itab.Fun[idx]`. ĞŸĞ¾ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ¿Ğ¾Ñ€ÑĞ´Ğ¾Ğº Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² **Ñ„Ğ¸ĞºÑĞ¸Ñ€ÑƒĞµÑ‚ÑÑ** Ğ½Ğ° ÑÑ‚Ğ°Ğ¿Ğµ ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ†Ğ¸Ğ¸ Ğ¸ Ğ¾Ğ´Ğ¸Ğ½Ğ°ĞºĞ¾Ğ² Ğ´Ğ»Ñ Ğ²ÑĞµÑ… Ñ‚Ğ¸Ğ¿Ğ¾Ğ².

**ĞŸĞ¾Ñ€ÑĞ´Ğ¾Ğº Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² Ğ² Fun[]** Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ÑÑ Ğ°Ğ»Ñ„Ğ°Ğ²Ğ¸Ñ‚Ğ½Ñ‹Ğ¼ Ğ¿Ğ¾Ñ€ÑĞ´ĞºĞ¾Ğ¼ Ğ¸Ğ¼Ñ‘Ğ½ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ²:

```go
// io.ReadWriteCloser
// Fun[0] = Close  (C < R < W)
// Fun[1] = Read
// Fun[2] = Write
```

## itab Caching

Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ `itab` Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ğ¿Ğ¾Ğ¸ÑĞºĞ° Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² â€” O(nÃ—m) Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ. Go ĞºĞµÑˆĞ¸Ñ€ÑƒĞµÑ‚ Ğ²ÑĞµ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ itab Ğ² Ğ³Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ hash table.

ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ ÑÑ‚Ğ¾ Ğ²Ğ°Ğ¶Ğ½Ğ¾: Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² Ğ´Ğ¾Ñ€Ğ¾Ğ³, Ğ° itab Ğ¿ĞµÑ€ĞµĞ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ Ğ´Ğ»Ñ Ğ¿Ğ°Ñ€Ñ‹ (interface type, concrete type).

```
itab lookup flow
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ getitab()    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ hash
       â–¼
  [Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° itab]
   â”‚ hit? â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ yes  â”‚ return itab   â”‚
   â”‚ no   â”‚ createItab()  â”‚
   â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ insert
                  â–¼
              return itab
```

### Hash Table ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°

```go
// runtime/iface.go
const itabInitSize = 512

// Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° itab
var (
    itabLock mutex
    itabTable = &itabTableType{
        size:    itabInitSize,
        count:   0,
        entries: make([]unsafe.Pointer, itabInitSize),
    }
)
```

```
itab Hash Table
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ size: 512    count: 47                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ entries[]                                                  â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚  0   â”‚  1   â”‚  2   â”‚  3   â”‚  4   â”‚  5   â”‚ ...  â”‚ 511  â”‚  â”‚
â”‚ â”‚ nil  â”‚ itab â”‚ nil  â”‚ itab â”‚ nil  â”‚ itab â”‚      â”‚ nil  â”‚  â”‚
â”‚ â”‚      â”‚  â†“   â”‚      â”‚  â†“   â”‚      â”‚  â†“   â”‚      â”‚      â”‚  â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”¼â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”¼â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”¼â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚           â”‚             â”‚             â”‚                    â”‚
â”‚           â–¼             â–¼             â–¼                    â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚       â”‚ itab  â”‚     â”‚ itab  â”‚     â”‚ itab  â”‚                â”‚
â”‚       â”‚Writer â”‚     â”‚Reader â”‚     â”‚Stringer                â”‚
â”‚       â”‚*File  â”‚     â”‚*Bufferâ”‚     â”‚myType â”‚                â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Lookup Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼

```go
// runtime/iface.go (ÑƒĞ¿Ñ€Ğ¾Ñ‰Ñ‘Ğ½Ğ½Ğ¾)
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
    // Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ hash Ğ¸Ğ· Ğ¿Ğ°Ñ€Ñ‹ (inter, typ)
    h := itabHashFunc(inter, typ) % len(itabTable.entries)

    // Ğ˜Ñ‰ĞµĞ¼ Ğ² Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğµ (linear probing Ğ¿Ñ€Ğ¸ ĞºĞ¾Ğ»Ğ»Ğ¸Ğ·Ğ¸ÑÑ…)
    for {
        p := atomic.Loadp(&itabTable.entries[h])
        if p == nil {
            break // Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½
        }
        t := (*itab)(p)
        if t.Inter == inter && t.Type == typ {
            return t // Ğ½Ğ°Ğ¹Ğ´ĞµĞ½!
        }
        h = (h + 1) % len(itabTable.entries)
    }

    // ĞĞµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ â€” ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ½Ğ¾Ğ²Ñ‹Ğ¹
    return createItab(inter, typ)
}
```

Ğ£Ğ¿Ñ€Ğ¾Ñ‰Ñ‘Ğ½Ğ½Ğ¾:
1. ĞŸĞ¾ÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ hash Ğ¿Ğ°Ñ€Ñ‹ (interface type, concrete type)
2. Linear probing Ğ¿Ñ€Ğ¸ ĞºĞ¾Ğ»Ğ»Ğ¸Ğ·Ğ¸ÑÑ…
3. Ğ•ÑĞ»Ğ¸ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾ â†’ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ itab

Ğ¡Ñ€ĞµĞ´Ğ½Ğ¸Ğ¹ ÑĞ»ÑƒÑ‡Ğ°Ğ¹ â€” O(1), Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼Ñƒ Ñ‡Ñ‚Ğ¾ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ÑÑ Ñ Ğ½ĞµĞ²Ñ‹ÑĞ¾ĞºĞ¾Ğ¹ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¾Ğ¹.

### Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ itab

```go
func createItab(inter *interfacetype, typ *_type) *itab {
    // 1. ĞĞ»Ğ»Ğ¾Ñ†Ğ¸Ñ€ÑƒĞµĞ¼ itab (Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ° Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ²)
    m := &itab{
        Inter: inter,
        Type:  typ,
        Hash:  typ.Hash,
    }

    // 2. Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Fun[] â€” Ğ¸Ñ‰ĞµĞ¼ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ Ñ‚Ğ¸Ğ¿Ğ° Ğ¿Ğ¾ Ğ¸Ğ¼ĞµĞ½Ğ°Ğ¼ Ğ¸Ğ· Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ°
    methods := typ.Methods()
    for i, im := range inter.Methods {
        // Ğ‘Ğ¸Ğ½Ğ°Ñ€Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ° Ğ² Ğ¾Ñ‚ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ¼ ÑĞ¿Ğ¸ÑĞºĞµ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¾Ğ² Ñ‚Ğ¸Ğ¿Ğ°
        j := sort.Search(len(methods), func(j int) bool {
            return methods[j].Name >= im.Name
        })
        if j < len(methods) && methods[j].Name == im.Name {
            m.Fun[i] = methods[j].Fn
        } else {
            // ĞœĞµÑ‚Ğ¾Ğ´ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ â€” Ñ‚Ğ¸Ğ¿ Ğ½Ğµ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞµÑ‚ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ
            return nil
        }
    }

    // 3. Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² ĞºĞµÑˆ
    itabAdd(m)

    return m
}
```

ĞĞ° ÑÑ‚Ğ¾Ğ¼ ÑˆĞ°Ğ³Ğµ Ğ¿Ñ€Ğ¾Ğ¸ÑÑ…Ğ¾Ğ´Ğ¸Ñ‚ **Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ°**: ĞµÑĞ»Ğ¸ Ğ¼ĞµÑ‚Ğ¾Ğ´ Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚, ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ itab Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ°ĞµÑ‚ÑÑ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¾Ğ¹. Ğ­Ñ‚Ğ¾ Ñ‚Ğ¾ Ğ¼ĞµÑÑ‚Ğ¾, Ğ³Ğ´Ğµ runtime Ñ€ĞµÑˆĞ°ĞµÑ‚, Ñ‡Ñ‚Ğ¾ Ñ‚Ğ¸Ğ¿ **Ğ½Ğµ Ñ€ĞµĞ°Ğ»Ğ¸Ğ·ÑƒĞµÑ‚** Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ğ¿Ñ€Ğ¸ assertion Ğ¸Ğ»Ğ¸ Ğ¿Ñ€Ğ¸ Ğ¿Ñ€Ğ¸Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğ¸.

### itab Table Growth

ĞŸÑ€Ğ¸ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğ¸ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ Ğ½Ğ° ~75% Ğ¿Ñ€Ğ¾Ğ¸ÑÑ…Ğ¾Ğ´Ğ¸Ñ‚ Ñ€Ğ¾ÑÑ‚:

```go
func itabAdd(m *itab) {
    if itabTable.count >= itabTable.size * 3 / 4 {
        // Ğ£Ğ´Ğ²Ğ°Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹
        grow := itabTable.size * 2
        newEntries := make([]unsafe.Pointer, grow)

        // Ğ ĞµÑ…ĞµÑˆĞ¸Ñ€ÑƒĞµĞ¼ Ğ²ÑĞµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğµ itab
        for _, p := range itabTable.entries {
            if p != nil {
                h := itabHashFunc((*itab)(p).Inter, (*itab)(p).Type) % grow
                // ... Ğ²ÑÑ‚Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ² Ğ½Ğ¾Ğ²ÑƒÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ
            }
        }

        itabTable.entries = newEntries
        itabTable.size = grow
    }

    // Ğ’ÑÑ‚Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ itab
    h := itabHashFunc(m.Inter, m.Type) % itabTable.size
    // ... linear probing Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ° ÑĞ²Ğ¾Ğ±Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ ÑĞ»Ğ¾Ñ‚Ğ°
    atomic.StorepNoWB(&itabTable.entries[h], unsafe.Pointer(m))
    itabTable.count++
}
```

Ğ Ğ¾ÑÑ‚ ÑƒĞ¼ĞµĞ½ÑŒÑˆĞ°ĞµÑ‚ ĞºĞ¾Ğ»Ğ»Ğ¸Ğ·Ğ¸Ğ¸ Ğ¸ Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ Ğ¿Ğ¾Ğ¸ÑĞº Ğ² ÑÑ€ĞµĞ´Ğ½ĞµĞ¼ O(1); Ğ´Ğ¾Ñ€Ğ¾Ğ³Ğ¸Ğµ Ğ²ÑÑ‚Ğ°Ğ²ĞºĞ¸ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ñ€Ğ¸ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ğ¸.

## _type Structure (Type Descriptor)

`_type` ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ Ğ²ÑÑ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ñ‚Ğ¸Ğ¿Ğµ, Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼ÑƒÑ runtime:

```go
// internal/abi/type.go
type Type struct {
    Size_       uintptr   // Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ñ‚Ğ¸Ğ¿Ğ° Ğ² Ğ±Ğ°Ğ¹Ñ‚Ğ°Ñ…
    PtrBytes    uintptr   // Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ prefix Ñ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸
    Hash        uint32    // hash Ñ‚Ğ¸Ğ¿Ğ° Ğ´Ğ»Ñ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾Ğ³Ğ¾ ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ñ
    TFlag       TFlag     // Ñ„Ğ»Ğ°Ğ³Ğ¸ (extraStar, named, etc.)
    Align_      uint8     // Ğ²Ñ‹Ñ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ
    FieldAlign_ uint8     // Ğ²Ñ‹Ñ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹
    Kind_       Kind      // Ğ²Ğ¸Ğ´ Ñ‚Ğ¸Ğ¿Ğ° (Int, Struct, Ptr, etc.)
    // ...
}
```

ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ğ¿Ğ¾Ğ»Ñ:
- `Size_`, `Align_`, `FieldAlign_` â€” Ñ€Ğ°Ğ·Ğ¼ĞµÑ‰ĞµĞ½Ğ¸Ğµ Ğ¸ ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
- `PtrBytes` â€” ÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ±Ğ°Ğ¹Ñ‚ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸ (Ğ²Ğ°Ğ¶Ğ½Ğ¾ Ğ´Ğ»Ñ GC)
- `Hash`, `Kind_` â€” ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ, type switch, reflect

### Type Kinds

```go
const (
    Invalid Kind = iota
    Bool
    Int
    Int8
    Int16
    Int32
    Int64
    Uint
    // ... Ñ‡Ğ¸ÑĞ»Ğ¾Ğ²Ñ‹Ğµ Ñ‚Ğ¸Ğ¿Ñ‹
    String
    UnsafePointer
    Array
    Chan
    Func
    Interface
    Map
    Pointer
    Slice
    Struct
)
```

`Kind` â€” Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ‚Ğ¾Ñ€ Ñ‚Ğ¸Ğ¿Ğ° Ğ´Ğ»Ñ Ğ²ĞµÑ‚Ğ²Ğ»ĞµĞ½Ğ¸Ğ¹ runtime.

### _type Ğ´Ğ»Ñ Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ñ‚Ğ¸Ğ¿Ğ¾Ğ²

```
_type Ğ´Ğ»Ñ int                    _type Ğ´Ğ»Ñ *os.File
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Size_: 8            â”‚          â”‚ Size_: 8            â”‚
â”‚ Hash:  0x...        â”‚          â”‚ Hash:  0x...        â”‚
â”‚ Kind_: Int          â”‚          â”‚ Kind_: Pointer      â”‚
â”‚ Align_: 8           â”‚          â”‚ Elem:  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ _type Ğ´Ğ»Ñ os.File
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

_type Ğ´Ğ»Ñ []byte                 _type Ğ´Ğ»Ñ struct{x int; y string}
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Size_: 24           â”‚          â”‚ Size_: 24                        â”‚
â”‚ Kind_: Slice        â”‚          â”‚ Kind_: Struct                    â”‚
â”‚ Elem:  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚          â”‚ Fields: [                        â”‚
â”‚   _type Ğ´Ğ»Ñ uint8   â”‚          â”‚   {Name: "x", Type: *int, ...}   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚   {Name: "y", Type: *string, ...}â”‚
                                 â”‚ ]                                â”‚
                                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Ğ¡Ğ¾ÑÑ‚Ğ°Ğ²Ğ½Ñ‹Ğµ Ñ‚Ğ¸Ğ¿Ñ‹ ÑÑÑ‹Ğ»Ğ°ÑÑ‚ÑÑ Ğ½Ğ° Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ `_type`:
- `Pointer` Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ ÑÑÑ‹Ğ»ĞºÑƒ Ğ½Ğ° `Elem`
- `Slice` Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ `Elem` Ğ¸ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ°
- `Struct` Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ Ğ¼Ğ°ÑÑĞ¸Ğ² Ğ¿Ğ¾Ğ»ĞµĞ¹ (Ğ¸Ğ¼Ñ, Ñ‚Ğ¸Ğ¿, offset)

Ğ­Ñ‚Ğ° Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ½ÑƒĞ¶Ğ½Ğ° Ğ´Ğ»Ñ `reflect`, ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ñ Ğ¸ GCâ€‘ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ.

## Interface Value Boxing

ĞŸÑ€Ğ¸ Ğ¿Ñ€Ğ¸ÑĞ²Ğ°Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğ¸ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑÑƒ Ğ¿Ñ€Ğ¾Ğ¸ÑÑ…Ğ¾Ğ´Ğ¸Ñ‚ "boxing" â€” ÑƒĞ¿Ğ°ĞºĞ¾Ğ²ĞºĞ° Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ:

### convT Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸

Runtime Ğ¸Ğ¼ĞµĞµÑ‚ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ´Ğ»Ñ boxing Ñ€Ğ°ÑĞ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ°Ğ½Ñ‘Ğ½Ğ½Ñ‹Ñ… Ñ‚Ğ¸Ğ¿Ğ¾Ğ²:

```go
// runtime/iface.go
func convT(t *_type, v unsafe.Pointer) unsafe.Pointer  // generic
func convTnoptr(t *_type, v unsafe.Pointer) unsafe.Pointer // Ğ±ĞµĞ· ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ĞµĞ¹
func convT16(val uint16) unsafe.Pointer
func convT32(val uint32) unsafe.Pointer
func convT64(val uint64) unsafe.Pointer
func convTstring(val string) unsafe.Pointer
func convTslice(val []byte) unsafe.Pointer
```

Ğ˜Ğ´ĞµÑ: Ğ´Ğ»Ñ Ñ‡Ğ°ÑÑ‚Ñ‹Ñ… Ñ‚Ğ¸Ğ¿Ğ¾Ğ² runtime ÑƒĞ¿Ğ°ĞºĞ¾Ğ²Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ±Ñ‹ÑÑ‚Ñ€ĞµĞµ, Ñ‡ĞµĞ¼ Ğ¾Ğ±Ñ‰Ğ¸Ğ¹ `convT`.

### Boxing ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¸

```go
// 1. Ğ£ĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ â€” Ğ±ĞµĞ· Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ğ¸, data = ÑĞ°Ğ¼ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ
var w io.Writer = &buf  // data = &buf

// 2. ĞœĞ°Ğ»ĞµĞ½ÑŒĞºĞ¸Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ â€” Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ "direct iface"
// Ğ•ÑĞ»Ğ¸ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ¼ĞµÑ‰Ğ°ĞµÑ‚ÑÑ Ğ² ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ Ğ¸ Ğ½Ğµ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ĞµĞ¹:
var x any = int64(42)  // Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ±ĞµĞ· Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ğ¸

// 3. ĞÑƒĞ»ĞµĞ²Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ â€” ÑÑ‚Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ zeroVal
var x any = 0          // data ÑƒĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ½Ğ° runtime.zeroVal
var y any = ""         // data ÑƒĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ½Ğ° runtime.zeroVal
var z any = false      // data ÑƒĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ½Ğ° runtime.zeroVal

// 4. Ğ‘Ğ¾Ğ»ÑŒÑˆĞ¸Ğµ Ğ¸Ğ»Ğ¸ ÑĞ¾ ÑÑÑ‹Ğ»ĞºĞ°Ğ¼Ğ¸ â€” Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ñ Ğ½Ğ° heap
var s any = MyStruct{} // ĞºĞ¾Ğ¿Ğ¸Ñ Ğ½Ğ° heap
```

ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸: boxing ĞºĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµÑ‚ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ¸ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ°Ğ»Ğ»Ğ¾Ñ†Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² Ñ†Ğ¸ĞºĞ»Ğ°Ñ….

### convT64 Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€

```go
// runtime/iface.go
func convT64(val uint64) unsafe.Pointer {
    // ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ: ÑÑ‚Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¿ÑƒĞ» Ğ´Ğ»Ñ Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ¸Ñ… Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹
    if val < uint64(len(staticuint64s)) {
        return unsafe.Pointer(&staticuint64s[val])
    }
    // Ğ˜Ğ½Ğ°Ñ‡Ğµ Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ñ
    p := mallocgc(8, uint64Type, false)
    *(*uint64)(p) = val
    return p
}

// Ğ¡Ñ‚Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¿ÑƒĞ» Ğ´Ğ»Ñ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹ 0-255
var staticuint64s = [256]uint64{0, 1, 2, 3, ..., 255}
```

Ğ¡Ğ¼Ñ‹ÑĞ»: Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ¸Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾Ğ²Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ² ÑÑ‚Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ¼ Ğ¼Ğ°ÑÑĞ¸Ğ²Ğµ Ğ±ĞµĞ· Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ğ¸.

### Direct Interface Optimization

Ğ”Ğ»Ñ Ñ‚Ğ¸Ğ¿Ğ¾Ğ², Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ğ¿Ğ¾Ğ¼ĞµÑ‰Ğ°ĞµÑ‚ÑÑ Ğ² ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ:

```go
// ĞšĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚:
// 1. Size <= PtrSize (8 Ğ±Ğ°Ğ¹Ñ‚ Ğ½Ğ° 64-bit)
// 2. Ğ¢Ğ¸Ğ¿ Ğ½Ğµ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ĞµĞ¹ (Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ GC Ğ½Ğµ ÑĞºĞ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ»)

// Direct iface Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶ĞµĞ½ Ğ´Ğ»Ñ:
// - int8, int16, int32, int64
// - uint8, uint16, uint32, uint64
// - float32, float64
// - bool
// - Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ¸Ğµ struct Ğ±ĞµĞ· ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ĞµĞ¹: struct{a, b int32}

type tinyStruct struct {
    a int32
    b int32
}

var x any = tinyStruct{1, 2}
// x.data ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ ÑĞ°Ğ¼Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ (packed Ğ² 8 Ğ±Ğ°Ğ¹Ñ‚)
// ĞĞ•Ğ¢ Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ğ¸ Ğ½Ğ° heap!
```

Ğ­Ñ‚Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ **pointer-free** Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹. Ğ•ÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸ â€” Ğ½ÑƒĞ¶Ğ½Ğ° Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ°Ñ Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ñ, Ğ¸Ğ½Ğ°Ñ‡Ğµ GC Ğ½Ğµ ÑƒĞ²Ğ¸Ğ´Ğ¸Ñ‚ ÑÑÑ‹Ğ»ĞºĞ¸.

## Method Dispatch

Ğ’Ñ‹Ğ·Ğ¾Ğ² Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ° Ñ‡ĞµÑ€ĞµĞ· Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ â€” ÑÑ‚Ğ¾ indirect call Ñ‡ĞµÑ€ĞµĞ· itab.fun[]:

```go
var w io.Writer = &buf
w.Write(data)  // ĞšĞ°Ğº ÑÑ‚Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚?
```

Ğ¨Ğ°Ğ³Ğ¸ dispatch:
1. Ğ‘ĞµÑ€Ñ‘Ğ¼ `w.tab` (itab)
2. Ğ”Ğ¾ÑÑ‚Ğ°Ñ‘Ğ¼ Ğ°Ğ´Ñ€ĞµÑ Ğ½ÑƒĞ¶Ğ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ° Ğ¸Ğ· `itab.Fun[i]`
3. ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‘Ğ¼ `w.data` ĞºĞ°Ğº receiver
4. Ğ”ĞµĞ»Ğ°ĞµĞ¼ indirect call

### Ğ¡ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´ (Ğ¿ÑĞµĞ²Ğ´Ğ¾-asm)

```asm
; w.Write(data)

; 1. Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ itab Ğ¸Ğ· iface
MOVQ    w+0(SP), AX        ; AX = w.tab (*itab)

; 2. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ° nil (panic ĞµÑĞ»Ğ¸ nil)
TESTQ   AX, AX
JZ      panic_nil_interface

; 3. Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ğ°Ğ´Ñ€ĞµÑ Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ° Ğ¸Ğ· itab.fun[0]
MOVQ    24(AX), CX         ; CX = itab.fun[0] = (*T).Write

; 4. Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ data (receiver)
MOVQ    w+8(SP), DX        ; DX = w.data

; 5. Ğ’Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ Ğ¼ĞµÑ‚Ğ¾Ğ´
CALL    CX                 ; (*T).Write(DX, data)
```

Ğ’Ğ°Ğ¶Ğ½Ğ¾: ĞµÑĞ»Ğ¸ `w` = `nil` Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ, Ñ‚Ğ¾ `tab` Ğ±ÑƒĞ´ĞµÑ‚ `nil` Ğ¸ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ¾Ğ¹Ğ´Ñ‘Ñ‚ panic ĞµÑ‰Ñ‘ **Ğ´Ğ¾** Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ° Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ°.

### Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ dispatch

```
Direct call:     CALL target          ; 1 Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ†Ğ¸Ñ
Interface call:  MOVQ (iface), AX     ; Ğ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ itab
                 MOVQ 24(AX), CX      ; Ğ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ fun[i]
                 CALL CX              ; indirect call
```

**Overhead:**
- 2 Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ñ… load Ğ¸Ğ· Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸
- Indirect call Ğ¼ĞµĞ½ĞµĞµ Ğ¿Ñ€ĞµĞ´ÑĞºĞ°Ğ·ÑƒĞµĞ¼ Ğ´Ğ»Ñ CPU branch predictor
- ĞĞ¾ ÑĞ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ CPU Ñ…Ğ¾Ñ€Ğ¾ÑˆĞ¾ ÑĞ¿Ñ€Ğ°Ğ²Ğ»ÑÑÑ‚ÑÑ Ñ Ğ¿Ñ€ĞµĞ´ÑĞºĞ°Ğ·Ğ°Ğ½Ğ¸ĞµĞ¼ indirect calls

ĞĞ° Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞµ ÑÑ‚Ğ¾ Ğ¾Ğ·Ğ½Ğ°Ñ‡Ğ°ĞµÑ‚: overhead Ğ·Ğ°Ğ¼ĞµÑ‚ĞµĞ½ Ğ² tight loops, Ğ½Ğ¾ Ğ² IOâ€‘ĞºĞ¾Ğ´Ğµ Ñ‡Ğ°ÑÑ‚Ğ¾ Ñ‚ĞµÑ€ÑĞµÑ‚ÑÑ Ğ½Ğ° Ñ„Ğ¾Ğ½Ğµ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ñ… Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ¾Ğ².

<InterfaceMemoryViz />

## Interface Comparison

Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑÑ‹ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ ÑÑ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°Ñ‚ÑŒ Ñ‡ĞµÑ€ĞµĞ· `==`:

```go
var a, b io.Reader
a = &buf1
b = &buf2

// Ğ¡Ñ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ¾Ğ²
if a == b { ... }
```

### ĞĞ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ñ

```go
// runtime/iface.go
func ifaceeq(t *_type, x, y unsafe.Pointer) bool {
    if t == nil {
        // ĞĞ±Ğ° nil
        return true
    }
    // Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ equal function Ğ¸Ğ· type descriptor
    return t.Equal(x, y)
}
```

Ğ¡Ñ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ¾Ğ² Ğ´ĞµĞ»Ğ°ĞµÑ‚ Ğ´Ğ²Ğµ Ğ²ĞµÑ‰Ğ¸:
1. Ğ¡Ñ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°ĞµÑ‚ **Ğ´Ğ¸Ğ½Ğ°Ğ¼Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ñ‚Ğ¸Ğ¿Ñ‹**
2. Ğ•ÑĞ»Ğ¸ Ñ‚Ğ¸Ğ¿Ñ‹ Ñ€Ğ°Ğ²Ğ½Ñ‹ â€” ÑÑ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ñ‡ĞµÑ€ĞµĞ· Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ `Equal` Ñƒ `_type`

**ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ°:**
1. ĞĞ±Ğ° nil â†’ Ñ€Ğ°Ğ²Ğ½Ñ‹
2. ĞĞ´Ğ¸Ğ½ nil, Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ½ĞµÑ‚ â†’ Ğ½Ğµ Ñ€Ğ°Ğ²Ğ½Ñ‹
3. Ğ Ğ°Ğ·Ğ½Ñ‹Ğµ dynamic types â†’ Ğ½Ğµ Ñ€Ğ°Ğ²Ğ½Ñ‹
4. ĞĞ´Ğ¸Ğ½Ğ°ĞºĞ¾Ğ²Ñ‹Ğµ types â†’ ÑÑ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ñ‡ĞµÑ€ĞµĞ· `_type.Equal`

### Panic Ğ¿Ñ€Ğ¸ ÑÑ€Ğ°Ğ²Ğ½ĞµĞ½Ğ¸Ğ¸

```go
type MySlice []int

var a, b any
a = MySlice{1, 2}
b = MySlice{1, 2}

if a == b { } // ğŸ’¥ PANIC: comparing uncomparable type MySlice
```

Slices, maps, functions â€” Ğ½ĞµĞ»ÑŒĞ·Ñ ÑÑ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°Ñ‚ÑŒ, Ğ´Ğ°Ğ¶Ğµ Ñ‡ĞµÑ€ĞµĞ· Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ.

ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°: Ğ´Ğ»Ñ Ñ‚Ğ°ĞºĞ¸Ñ… Ñ‚Ğ¸Ğ¿Ğ¾Ğ² Ğ½ĞµÑ‚ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ `==`, Ğ¿Ğ¾ÑÑ‚Ğ¾Ğ¼Ñƒ `Equal` Ğ½Ğµ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»Ñ‘Ğ½ â€” runtime Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚.

## ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ

### Escape Analysis Ğ²Ğ»Ğ¸ÑĞ½Ğ¸Ğµ

```go
// ĞĞµ escape â€” Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ñ Ğ½Ğ° ÑÑ‚ĞµĞºĞµ (Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾)
func process(r io.Reader) {
    // r Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾
    buf := make([]byte, 1024)
    r.Read(buf)
}

// Escape â€” Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ñ Ğ½Ğ° heap (Ğ¼ĞµĞ´Ğ»ĞµĞ½Ğ½ĞµĞµ)
func getReader() io.Reader {
    buf := &bytes.Buffer{}  // escape Ğ½Ğ° heap
    return buf              // ÑĞ¾Ñ…Ñ€Ğ°Ğ½ÑĞµÑ‚ÑÑ Ğ² Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ
}
```

ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ ÑÑ‚Ğ¾ Ğ¿Ñ€Ğ¾Ğ¸ÑÑ…Ğ¾Ğ´Ğ¸Ñ‚: ĞºĞ¾Ğ³Ğ´Ğ° Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ÑÑ ĞºĞ°Ğº Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ, ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€ Ñ‡Ğ°ÑÑ‚Ğ¾ Ğ²Ñ‹Ğ½ÑƒĞ¶Ğ´ĞµĞ½ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ ĞµĞ³Ğ¾ Ğ² heap, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ» ÑÑ‚Ğ°Ğ±Ğ¸Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ°Ğ´Ñ€ĞµÑ.

### Devirtualization

ĞšĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€ Ğ¼Ğ¾Ğ¶ĞµÑ‚ ÑƒĞ±Ñ€Ğ°Ñ‚ÑŒ indirect call, ĞµÑĞ»Ğ¸ Ğ·Ğ½Ğ°ĞµÑ‚ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿:

```go
func process(w io.Writer) {
    w.Write(data)
}

// Ğ˜Ğ½Ğ»Ğ°Ğ¹Ğ½Ğ¸Ğ½Ğ³ + devirtualization:
func main() {
    var buf bytes.Buffer
    process(&buf)  // ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¸Ğ½Ğ»Ğ°Ğ¹Ğ½Ğ¸Ñ‚ÑŒ Write Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ
}
```

Ğ•ÑĞ»Ğ¸ ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€ Ğ²Ğ¸Ğ´Ğ¸Ñ‚ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ğ¹ Ñ‚Ğ¸Ğ¿ Ğ² Ğ¼ĞµÑÑ‚Ğµ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ°, Ğ¾Ğ½ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ñ€ĞµĞ²Ñ€Ğ°Ñ‚Ğ¸Ñ‚ÑŒ `w.Write` Ğ² Ğ¿Ñ€ÑĞ¼Ğ¾Ğ¹ Ğ²Ñ‹Ğ·Ğ¾Ğ² Ğ¸ ÑƒĞ±Ñ€Ğ°Ñ‚ÑŒ overhead Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ°.

### Benchmark: interface vs direct call

```go
func BenchmarkDirectCall(b *testing.B) {
    buf := &bytes.Buffer{}
    data := []byte("hello")
    for i := 0; i < b.N; i++ {
        buf.Write(data)  // direct call
    }
}

func BenchmarkInterfaceCall(b *testing.B) {
    var w io.Writer = &bytes.Buffer{}
    data := []byte("hello")
    for i := 0; i < b.N; i++ {
        w.Write(data)  // interface call
    }
}

// Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ (Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ½Ñ‹Ğµ):
// BenchmarkDirectCall-8       100000000    11.2 ns/op
// BenchmarkInterfaceCall-8    100000000    12.8 ns/op
// Ğ Ğ°Ğ·Ğ½Ğ¸Ñ†Ğ° Ğ² ÑÑ‚Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğµ: ~15%
// Ğ¦Ğ¸Ñ„Ñ€Ñ‹ Ğ·Ğ°Ğ²Ğ¸ÑÑÑ‚ Ğ¾Ñ‚ CPU, Ğ²ĞµÑ€ÑĞ¸Ğ¸ Go Ğ¸ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¹ ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€Ğ°
```

Ğ¢Ğ°ĞºĞ¸Ğµ Ğ±ĞµĞ½Ñ‡Ğ¼Ğ°Ñ€ĞºĞ¸ Ğ¿Ğ¾Ğ»ĞµĞ·Ğ½Ñ‹ ĞºĞ°Ğº **Ğ¾Ñ€Ğ¸ĞµĞ½Ñ‚Ğ¸Ñ€**, Ğ½Ğ¾ Ğ²ÑĞµĞ³Ğ´Ğ° Ğ¸Ğ·Ğ¼ĞµÑ€ÑĞ¹Ñ‚Ğµ ÑĞ²Ğ¾Ğ¸ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğµ hot paths.

## Ğ¤Ğ°Ğ¹Ğ»Ñ‹ runtime/

| Ğ¤Ğ°Ğ¹Ğ» | ĞĞ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ |
|------|------------|
| `runtime/iface.go` | ĞĞ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ñ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ°Ğ¼Ğ¸: getitab, convT*, assertI2I |
| `runtime/runtime2.go` | ĞĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ iface, eface, itab |
| `internal/abi/iface.go` | ITab ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° (ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼Ğ°Ñ) |
| `internal/abi/type.go` | _type Ğ¸ ÑĞ²ÑĞ·Ğ°Ğ½Ğ½Ñ‹Ğµ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ |
| `cmd/compile/internal/ir/func.go` | Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ method dispatch ĞºĞ¾Ğ´Ğ° |

## Ğ’Ñ‹Ğ²Ğ¾Ğ´Ñ‹

1. **iface vs eface** â€” Ğ´Ğ²Ğ° Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ¿ÑƒÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑĞ°

2. **itab** â€” Ñ†ĞµĞ½Ñ‚Ñ€Ğ°Ğ»ÑŒĞ½Ğ°Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ method dispatch, ĞºĞµÑˆĞ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ³Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ğ¾

3. **Boxing** Ğ¸Ğ¼ĞµĞµÑ‚ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Ğ¼Ğ°Ğ»ĞµĞ½ÑŒĞºĞ¸Ñ… Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹ Ğ¸ ÑÑ‚Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¿ÑƒĞ» Ğ´Ğ»Ñ Ñ‡Ğ°ÑÑ‚Ñ‹Ñ… Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğ¹

4. **Method dispatch** â€” indirect call Ñ‡ĞµÑ€ĞµĞ· itab.fun[], overhead Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾ Ğ½ĞµĞ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹, Ğ¸Ğ·Ğ¼ĞµÑ€ÑĞ¹Ñ‚Ğµ Ğ² ÑĞ²Ğ¾Ñ‘Ğ¼ ĞºĞ¾Ğ´Ğµ

5. **Escape analysis** ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ğ° â€” Ğ¿Ñ€Ğ¸ÑĞ²Ğ°Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹ÑÑƒ Ñ‡Ğ°ÑÑ‚Ğ¾ Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ escape Ğ½Ğ° heap

## Sources

- [Runtime source: runtime/iface.go](https://go.dev/src/runtime/iface.go)
- [Runtime source: runtime/runtime2.go](https://go.dev/src/runtime/runtime2.go)
- [Runtime source: internal/abi/iface.go](https://go.dev/src/internal/abi/iface.go)
- [Go spec: Interface types](https://go.dev/ref/spec#Interface_types)
- [Go spec: Method sets](https://go.dev/ref/spec#Method_sets)
