# Concurrency Ğ² Go

<div class="hero-section">
  <img src="/images/concurrency.avif" alt="Concurrency" class="hero-image" />
</div>

Go Ğ±Ñ‹Ğ» ÑĞ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½ Ñ ÑƒÑ‡Ñ‘Ñ‚Ğ¾Ğ¼ ĞºĞ¾Ğ½ĞºÑƒÑ€ĞµĞ½Ñ‚Ğ½Ğ¾ÑÑ‚Ğ¸ ĞºĞ°Ğº Ğ¿ĞµÑ€Ğ²Ğ¾ĞºĞ»Ğ°ÑÑĞ½Ğ¾Ğ¹ ĞºĞ¾Ğ½Ñ†ĞµĞ¿Ñ†Ğ¸Ğ¸. Ğ’ Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ¸Ğµ Ğ¾Ñ‚ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¸Ğ½ÑÑ‚Ğ²Ğ° ÑĞ·Ñ‹ĞºĞ¾Ğ², Ğ³Ğ´Ğµ concurrency â€” ÑÑ‚Ğ¾ Ğ±Ğ¸Ğ±Ğ»Ğ¸Ğ¾Ñ‚ĞµÑ‡Ğ½Ğ°Ñ Ğ½Ğ°Ğ´ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ°, Ğ² Go Ğ¾Ğ½Ğ° Ğ²ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ° Ğ² ÑĞ°Ğ¼ ÑĞ·Ñ‹Ğº Ğ¸ runtime.

## TL;DR: ĞŸÑ€Ğ¸Ğ¼Ğ¸Ñ‚Ğ¸Ğ²Ñ‹ ĞºĞ¾Ğ½ĞºÑƒÑ€ĞµĞ½Ñ‚Ğ½Ğ¾ÑÑ‚Ğ¸

| ĞŸÑ€Ğ¸Ğ¼Ğ¸Ñ‚Ğ¸Ğ² | ĞĞ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ | Overhead | ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ |
|----------|------------|----------|-------------------|
| **Goroutine** | Ğ•Ğ´Ğ¸Ğ½Ğ¸Ñ†Ğ° Ğ¿Ğ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ | ~2KB stack, ~300ns spawn | Ğ›ÑĞ±Ğ°Ñ Ğ°ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ°Ñ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ |
| **Channel** | ĞšĞ¾Ğ¼Ğ¼ÑƒĞ½Ğ¸ĞºĞ°Ñ†Ğ¸Ñ Ğ¼ĞµĞ¶Ğ´Ñƒ goroutines | ~96 bytes + buffer | ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…/ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ¾Ğ² |
| **Context** | Cancellation + deadline + values | ~48-80 bytes per ctx | Request-scoped Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ, timeouts |
| **sync.Mutex** | Mutual exclusion | 8 bytes | Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ° shared state |
| **sync.RWMutex** | Read-heavy workloads | 24 bytes | ĞœĞ½Ğ¾Ğ³Ğ¾ Ñ‡Ğ¸Ñ‚Ğ°Ñ‚ĞµĞ»ĞµĞ¹, Ğ¼Ğ°Ğ»Ğ¾ Ğ¿Ğ¸ÑĞ°Ñ‚ĞµĞ»ĞµĞ¹ |
| **sync.WaitGroup** | ĞĞ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹ goroutines | 12 bytes | Fan-out / join patterns |
| **sync.Once** | ĞĞ´Ğ½Ğ¾Ñ€Ğ°Ğ·Ğ¾Ğ²Ğ°Ñ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ | 12 bytes | Lazy singleton |
| **sync.Pool** | Object reuse | Per-P pools | Hot path allocations |
| **sync.Map** | Concurrent map | ~2x memory vs map | Read-heavy + disjoint writes |
| **atomic** | Lock-free Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ | 0 overhead | Counters, flags, pointers |

## ĞĞ±Ğ·Ğ¾Ñ€ Ğ¿Ñ€Ğ¸Ğ¼Ğ¸Ñ‚Ğ¸Ğ²Ğ¾Ğ² ĞºĞ¾Ğ½ĞºÑƒÑ€ĞµĞ½Ñ‚Ğ½Ğ¾ÑÑ‚Ğ¸

<InteractiveModal title="Concurrency Overview" icon="ğŸ—ºï¸" description="Ğ˜Ğ½Ñ‚ĞµÑ€Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ°Ñ ĞºĞ°Ñ€Ñ‚Ğ° Ğ¿Ñ€Ğ¸Ğ¼Ğ¸Ñ‚Ğ¸Ğ²Ğ¾Ğ² ĞºĞ¾Ğ½ĞºÑƒÑ€ĞµĞ½Ñ‚Ğ½Ğ¾ÑÑ‚Ğ¸ Go">
  <ConcurrencyOverviewDiagram />
</InteractiveModal>

## CSP vs Shared Memory

Go Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ¾Ğ±Ğ° Ğ¿Ğ¾Ğ´Ñ…Ğ¾Ğ´Ğ°, Ğ½Ğ¾ Ğ¸Ğ´Ğ¸Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¿Ñ€ĞµĞ´Ğ¿Ğ¾Ñ‡Ğ¸Ñ‚Ğ°ĞµÑ‚ CSP (Communicating Sequential Processes):

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Concurrency Models Ğ² Go                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚    CSP (Channels)                      Shared Memory (sync/atomic)          â”‚
â”‚    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•          â”‚
â”‚                                                                             â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   channel   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” mutex â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚    â”‚Goroutineâ”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚Goroutineâ”‚     â”‚Goroutineâ”‚â—€â”€â”€â”€â”€â”€â–¶â”‚  Shared  â”‚   â”‚
â”‚    â”‚    A    â”‚             â”‚    B    â”‚     â”‚  A + B  â”‚       â”‚  State   â”‚   â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â”‚    Ownership transfer                   Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°                      â”‚
â”‚    "Don't communicate by               "Do share memory                     â”‚
â”‚     sharing memory"                     carefully with locks"               â”‚
â”‚                                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ĞšĞ¾Ğ³Ğ´Ğ° CSP:                           ĞšĞ¾Ğ³Ğ´Ğ° Shared Memory:                  â”‚
â”‚  â€¢ Pipeline Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ°                 â€¢ Simple counters (atomic)            â”‚
â”‚  â€¢ Fan-out / fan-in                   â€¢ Caches (sync.Map)                   â”‚
â”‚  â€¢ Event broadcasting                 â€¢ Object pools (sync.Pool)            â”‚
â”‚  â€¢ Request-response                   â€¢ Fine-grained locking                â”‚
â”‚  â€¢ Producer-consumer                  â€¢ Hot path performance                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ĞŸÑ€Ğ¸Ğ½Ñ†Ğ¸Ğ¿ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ°

```go
// âœ… CSP: Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ "Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰Ğ°ÑÑ‚ÑÑ" Ğ¼ĞµĞ¶Ğ´Ñƒ goroutines
func pipeline() {
    jobs := make(chan Job)
    results := make(chan Result)

    go worker(jobs, results)  // ownership transfer

    jobs <- job     // Ğ¾Ñ‚Ğ´Ğ°Ğ»Ğ¸ Ğ²Ğ»Ğ°Ğ´ĞµĞ½Ğ¸Ğµ
    r := <-results  // Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ»Ğ¸ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚
}

// âœ… Shared Memory: Ğ¾Ğ±Ñ‰Ğ¸Ğ¹ ĞºÑÑˆ Ñ Ñ€ĞµĞ´ĞºĞ¸Ğ¼Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑÑĞ¼Ğ¸
func cache() {
    var cache sync.Map

    // ĞœĞ½Ğ¾Ğ³Ğ¾ Ñ‡Ğ¸Ñ‚Ğ°Ñ‚ĞµĞ»ĞµĞ¹, Ñ€ĞµĞ´ĞºĞ¸Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸
    go func() { v, _ := cache.Load("key") }()
    go func() { cache.Store("key", value) }()
}
```

## ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ğ¿Ñ€Ğ¸Ğ¼Ğ¸Ñ‚Ğ¸Ğ²Ğ¾Ğ²

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                            Runtime Layer                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                         GMP Scheduler                               â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”                        â”‚    â”‚
â”‚  â”‚  â”‚  G  â”‚ â”‚  G  â”‚ â”‚  G  â”‚ ... â”‚  M  â”‚ â”‚  P  â”‚                        â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜                        â”‚    â”‚
â”‚  â”‚      â–²       â–²       â–²           â”‚       â”‚                          â”‚    â”‚
â”‚  â”‚      â”‚       â”‚       â”‚           â–¼       â–¼                          â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚    â”‚
â”‚  â”‚  â”‚              runtime.gopark / runtime.goready         â”‚          â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚           â”‚                                     â”‚                           â”‚
â”‚           â–¼                                     â–¼                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚      Channels       â”‚              â”‚    sync Package     â”‚               â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚              â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚               â”‚
â”‚  â”‚  â”‚ runtime.hchan â”‚  â”‚              â”‚  â”‚ sync.Mutex    â”‚  â”‚               â”‚
â”‚  â”‚  â”‚   â€¢ sendq     â”‚  â”‚              â”‚  â”‚ sync.RWMutex  â”‚  â”‚               â”‚
â”‚  â”‚  â”‚   â€¢ recvq     â”‚  â”‚              â”‚  â”‚ sync.WaitGroupâ”‚  â”‚               â”‚
â”‚  â”‚  â”‚   â€¢ buf       â”‚  â”‚              â”‚  â”‚ sync.Once     â”‚  â”‚               â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚              â”‚  â”‚ sync.Pool     â”‚  â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚  â”‚ sync.Map      â”‚  â”‚               â”‚
â”‚           â”‚                           â”‚  â”‚ sync.Cond     â”‚  â”‚               â”‚
â”‚           â”‚                           â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚               â”‚
â”‚           â”‚                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚           â”‚                                     â”‚                           â”‚
â”‚           â–¼                                     â–¼                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                         sync/atomic                                 â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚
â”‚  â”‚  â”‚atomic.Int64 â”‚ â”‚atomic.Bool  â”‚ â”‚atomic.Value â”‚ â”‚atomic.Ptr[T]â”‚    â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â”‚
â”‚  â”‚                         â”‚                                           â”‚    â”‚
â”‚  â”‚                         â–¼                                           â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚
â”‚  â”‚  â”‚               CPU Instructions (LOCK, CAS, etc.)            â”‚    â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                            Context Layer                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                         context.Context                             â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚    â”‚
â”‚  â”‚  â”‚emptyCtx  â”‚ â”‚cancelCtx â”‚ â”‚timerCtx  â”‚ â”‚valueCtx  â”‚ â”‚afterFunc â”‚   â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğ°

### [Goroutines](./goroutines)
Ğ–Ğ¸Ğ·Ğ½ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ†Ğ¸ĞºĞ» Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ñ‹: Ğ¾Ñ‚ `runtime.newproc` Ğ´Ğ¾ `goexit`. Ğ’ÑĞµ 10 ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğ¹ G, stack growth/shrinking, preemption (cooperative Ğ¸ async), `LockOSThread`, goroutine leaks Ğ¸ Ğ¸Ñ… Ğ´ĞµÑ‚ĞµĞºÑ†Ğ¸Ñ.

### [Channels](./channels)
Ğ’Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸ `runtime.hchan`: ring buffer, `sudog`, Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼Ñ‹ send/receive, direct send Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ, close ÑĞµĞ¼Ğ°Ğ½Ñ‚Ğ¸ĞºĞ°. Select: `scase` ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°, `selectgo` Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼, compiler Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸.

### [Context](./context)
Ğ¢Ğ¸Ğ¿Ñ‹ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²: `emptyCtx`, `cancelCtx`, `timerCtx`, `valueCtx`, `afterFuncCtx`. Cancellation propagation, lazy Done channel, Value lookup performance. Go 1.20+: Cause, Go 1.21+: WithoutCancel, AfterFunc.

### [sync Primitives](./sync-primitives)
Ğ’Ğ½ÑƒÑ‚Ñ€ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸ sync Ğ¿Ğ°ĞºĞµÑ‚Ğ°: Mutex starvation mode, RWMutex writer priority, WaitGroup atomic state, Once double-checked locking, Cond notifyList, Pool per-P + victim cache, Map read/dirty Ğ°Ğ¼Ğ¾Ñ€Ñ‚Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ.

### [Atomic Operations](./atomic)
`sync/atomic` typed wrappers (Go 1.19+), memory ordering (acquire-release), CPU Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ (x86 LOCK, ARM LDREX/STREX), lock-free ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹, false sharing.

### [Memory Model](./memory-model)
Go Memory Model: happens-before, ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹, data races Ğ¸ Ğ¸Ñ… Ğ¿Ğ¾ÑĞ»ĞµĞ´ÑÑ‚Ğ²Ğ¸Ñ. Race Detector: ThreadSanitizer, shadow memory, vector clocks, CI Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ.

### [Patterns](./patterns)
Production-ready Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹: pipelines, fan-out/fan-in, error handling (errgroup), rate limiting (token bucket), cancellation patterns, resource management (semaphore, bounded parallelism).

## Ğ¡Ğ²ÑĞ·ÑŒ Ñ GMP Scheduler

::: tip Ğ§Ñ‚Ğ¾ ÑƒĞ¶Ğµ Ñ€Ğ°ÑÑĞ¼Ğ¾Ñ‚Ñ€ĞµĞ½Ğ¾ Ğ² Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ğµ Runtime
Ğ Ğ°Ğ·Ğ´ĞµĞ» [GMP Scheduler](/01-runtime/gmp-scheduler) Ğ¿Ğ¾ĞºÑ€Ñ‹Ğ²Ğ°ĞµÑ‚:
- Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ `runtime.g`, `runtime.m`, `runtime.p`
- Work Stealing Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼
- Local/Global Run Queues
- GOMAXPROCS Ğ¸ ĞµĞ³Ğ¾ runtime Ğ°Ğ´Ğ°Ğ¿Ñ‚Ğ°Ñ†Ğ¸Ñ
- Scheduler Trace (`GODEBUG=schedtrace`)

Ğ—Ğ´ĞµÑÑŒ Ğ¼Ñ‹ Ñ„Ğ¾ĞºÑƒÑĞ¸Ñ€ÑƒĞµĞ¼ÑÑ Ğ½Ğ° **Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¸** ÑÑ‚Ğ¸Ñ… Ğ¼ĞµÑ…Ğ°Ğ½Ğ¸Ğ·Ğ¼Ğ¾Ğ² Ñ‡ĞµÑ€ĞµĞ· Ğ²Ñ‹ÑĞ¾ĞºĞ¾ÑƒÑ€Ğ¾Ğ²Ğ½ĞµĞ²Ñ‹Ğµ Ğ¿Ñ€Ğ¸Ğ¼Ğ¸Ñ‚Ğ¸Ğ²Ñ‹.
:::

## Performance Guidelines

### Goroutines
```go
// âŒ Avoid: goroutine per request Ğ±ĞµĞ· Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğ¹
for req := range requests {
    go handle(req)  // unbounded goroutines â†’ OOM
}

// âœ… Better: bounded concurrency
sem := make(chan struct{}, maxWorkers)
for req := range requests {
    sem <- struct{}{}
    go func(r Request) {
        defer func() { <-sem }()
        handle(r)
    }(req)
}
```

### Channels
```go
// âŒ Avoid: channel Ğ´Ğ»Ñ single value
ch := make(chan Result, 1)
go func() { ch <- compute() }()
result := <-ch

// âœ… Better: direct return Ñ‡ĞµÑ€ĞµĞ· closure
var result Result
var wg sync.WaitGroup
wg.Add(1)
go func() {
    defer wg.Done()
    result = compute()  // direct write, no channel overhead
}()
wg.Wait()
```

### sync.Pool
```go
// âŒ Avoid: Pool Ğ´Ğ»Ñ Ğ´Ğ¾Ğ»Ğ³Ğ¾Ğ¶Ğ¸Ğ²ÑƒÑ‰Ğ¸Ñ… Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ²
var connPool = sync.Pool{...}  // connections Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ±Ñ‹Ñ‚ÑŒ evicted Ğ² Ğ»ÑĞ±Ğ¾Ğ¹ Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚

// âœ… Better: Pool Ğ´Ğ»Ñ temporary buffers
var bufPool = sync.Pool{
    New: func() any { return make([]byte, 4096) },
}

func process(data []byte) {
    buf := bufPool.Get().([]byte)
    defer bufPool.Put(buf)
    // use buf
}
```

## Debugging & Tracing

```bash
# Goroutine dump
kill -SIGQUIT <pid>
# Ğ¸Ğ»Ğ¸
curl localhost:6060/debug/pprof/goroutine?debug=2

# Scheduler trace
GODEBUG=schedtrace=1000 ./app

# Race detector
go run -race ./...
go test -race ./...

# Trace
go test -trace trace.out
go tool trace trace.out
```
