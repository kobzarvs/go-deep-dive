# sync Package Internals

ĞŸĞ°ĞºĞµÑ‚ `sync` Ğ¿Ñ€ĞµĞ´Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ½Ğ¸Ğ·ĞºĞ¾ÑƒÑ€Ğ¾Ğ²Ğ½ĞµĞ²Ñ‹Ğµ Ğ¿Ñ€Ğ¸Ğ¼Ğ¸Ñ‚Ğ¸Ğ²Ñ‹ ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸. ĞŸĞ¾Ğ´ ĞºĞ°Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼ â€” ÑÑ‚Ğ¾ ĞºĞ¾Ğ¼Ğ±Ğ¸Ğ½Ğ°Ñ†Ğ¸Ñ atomic Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹, futex'Ğ¾Ğ² Ğ¸ Ñ‚ĞµÑĞ½Ğ°Ñ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ runtime.

## sync.Mutex

### Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°

```go
// sync/mutex.go
type Mutex struct {
    state int32   // Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ° (locked, woken, starving, waiters count)
    sema  uint32  // Ğ¡ĞµĞ¼Ğ°Ñ„Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½
}

// Ğ‘Ğ¸Ñ‚Ñ‹ Ğ² state:
const (
    mutexLocked      = 1 << iota  // bit 0: Ğ¼ÑŒÑÑ‚ĞµĞºÑ Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‡ĞµĞ½
    mutexWoken                     // bit 1: ĞµÑÑ‚ÑŒ Ğ¿Ñ€Ğ¾ÑĞ½ÑƒĞ²ÑˆĞ¸Ğ¹ÑÑ waiter
    mutexStarving                  // bit 2: Ñ€ĞµĞ¶Ğ¸Ğ¼ starvation
    mutexWaiterShift = iota        // bits 3+: ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ñ…
)
```

### State Encoding

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Mutex State (int32)                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚     Waiters Count         â”‚ Starving â”‚ Woken  â”‚ Locked â”‚                 â”‚
â”‚  â”‚        (29 bits)          â”‚  (1 bit) â”‚(1 bit) â”‚(1 bit) â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚  MSB                                                             LSB        â”‚
â”‚                                                                             â”‚
â”‚  ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:                                                                   â”‚
â”‚  â€¢ 0b00000001 = locked, no waiters                                          â”‚
â”‚  â€¢ 0b00001001 = locked, 1 waiter (8 = 1 << 3)                               â”‚
â”‚  â€¢ 0b00000101 = locked, starving mode                                       â”‚
â”‚  â€¢ 0b00000010 = unlocked, woken (someone spinning)                          â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Normal Mode vs Starvation Mode

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Mutex Modes (Go 1.9+)                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  NORMAL MODE                          STARVATION MODE                       â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•                         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                       â”‚
â”‚                                                                             â”‚
â”‚  â€¢ ĞĞ¾Ğ²Ñ‹Ğµ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ñ‹ ÑĞ¿Ğ¸Ğ½ÑÑ‚ÑÑ            â€¢ FIFO ÑÑ‚Ñ€Ğ¾Ğ³Ğ¾                         â”‚
â”‚  â€¢ ĞšĞ¾Ğ½ĞºÑƒÑ€Ğ¸Ñ€ÑƒÑÑ‚ Ñ waiters              â€¢ ĞĞ¾Ğ²Ñ‹Ğµ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ñ‹ ÑÑ€Ğ°Ğ·Ñƒ Ğ² Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ      â”‚
â”‚  â€¢ Ğ‘Ñ‹ÑÑ‚Ñ€ĞµĞµ Ğ´Ğ»Ñ low contention         â€¢ Ğ“Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€ÑƒĞµÑ‚ fairness                â”‚
â”‚                                                                             â”‚
â”‚  ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´ Ğ² starvation:                Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ² normal:                     â”‚
â”‚  waiter Ğ¶Ğ´Ñ‘Ñ‚ > 1ms                    â€¢ Waiter Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ğ» lock Ğ˜               â”‚
â”‚                                       â€¢ Ğ­Ñ‚Ğ¾ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ waiter Ğ˜Ğ›Ğ˜            â”‚
â”‚                                       â€¢ Ğ–Ğ´Ğ°Ğ» < 1ms                          â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” spin     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  FIFO   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚   New    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Compete  â”‚   â”‚   New    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  Queue   â”‚     â”‚
â”‚  â”‚ Goroutineâ”‚          â”‚  (fair)  â”‚   â”‚ Goroutineâ”‚         â”‚  (FIFO)  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

<InteractiveModal title="Mutex State Visualizer" icon="ğŸ”" description="Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğ¹ Mutex: Normal Mode vs Starvation Mode">
  <MutexStateViz />
</InteractiveModal>

### Lock Ğ°Ğ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼

```go
func (m *Mutex) Lock() {
    // Fast path: Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚Ğ¸Ñ‚ÑŒ unlocked mutex
    if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
        return
    }
    m.lockSlow()
}

func (m *Mutex) lockSlow() {
    var waitStartTime int64
    starving := false
    awoke := false
    iter := 0
    old := m.state

    for {
        // Spin Ğ² normal mode ĞµÑĞ»Ğ¸ mutex locked Ğ½Ğ¾ Ğ½Ğµ starving
        if old&(mutexLocked|mutexStarving) == mutexLocked &&
           runtime_canSpin(iter) {
            // ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ woken bit
            if !awoke && old&mutexWoken == 0 &&
               old>>mutexWaiterShift != 0 &&
               atomic.CompareAndSwapInt32(&m.state, old, old|mutexWoken) {
                awoke = true
            }
            runtime_doSpin()
            iter++
            old = m.state
            continue
        }

        new := old

        // ĞĞµ ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ locked Ğ² starvation mode (ÑÑ€Ğ°Ğ·Ñƒ Ğ² Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ)
        if old&mutexStarving == 0 {
            new |= mutexLocked
        }

        // Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ñ‚ÑŒ ÑÑ‡Ñ‘Ñ‚Ñ‡Ğ¸Ğº waiters
        if old&(mutexLocked|mutexStarving) != 0 {
            new += 1 << mutexWaiterShift
        }

        // ĞŸĞµÑ€ĞµĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ² starvation mode ĞµÑĞ»Ğ¸ Ğ¶Ğ´Ñ‘Ğ¼ Ğ´Ğ¾Ğ»Ğ³Ğ¾
        if starving && old&mutexLocked != 0 {
            new |= mutexStarving
        }

        // Ğ¡Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ woken ĞµÑĞ»Ğ¸ Ğ¼Ñ‹ Ğ±Ñ‹Ğ»Ğ¸ Ñ€Ğ°Ğ·Ğ±ÑƒĞ¶ĞµĞ½Ñ‹
        if awoke {
            new &^= mutexWoken
        }

        if atomic.CompareAndSwapInt32(&m.state, old, new) {
            if old&(mutexLocked|mutexStarving) == 0 {
                break  // Ğ—Ğ°Ñ…Ğ²Ğ°Ñ‚Ğ¸Ğ»Ğ¸ lock!
            }

            // Ğ–Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ° ÑĞµĞ¼Ğ°Ñ„Ğ¾Ñ€Ğµ
            queueLifo := waitStartTime != 0
            if waitStartTime == 0 {
                waitStartTime = runtime_nanotime()
            }
            runtime_SemacquireMutex(&m.sema, queueLifo, 1)

            // ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ starvation
            starving = starving ||
                       runtime_nanotime()-waitStartTime > starvationThresholdNs
            old = m.state

            if old&mutexStarving != 0 {
                // Ğ’ starvation mode â€” Ğ¼Ñ‹ Ğ²Ğ»Ğ°Ğ´ĞµĞµĞ¼ Ğ¼ÑŒÑÑ‚ĞµĞºÑĞ¾Ğ¼
                delta := int32(mutexLocked - 1<<mutexWaiterShift)
                if !starving || old>>mutexWaiterShift == 1 {
                    delta -= mutexStarving  // Ğ’Ñ‹Ğ¹Ñ‚Ğ¸ Ğ¸Ğ· starvation
                }
                atomic.AddInt32(&m.state, delta)
                break
            }
            awoke = true
            iter = 0
        } else {
            old = m.state
        }
    }
}
```

## sync.RWMutex

### Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°

```go
// sync/rwmutex.go
type RWMutex struct {
    w           Mutex   // Ğ”Ğ»Ñ exclusive lock Ğ¼ĞµĞ¶Ğ´Ñƒ writers
    writerSem   uint32  // Ğ¡ĞµĞ¼Ğ°Ñ„Ğ¾Ñ€ Ğ´Ğ»Ñ writers
    readerSem   uint32  // Ğ¡ĞµĞ¼Ğ°Ñ„Ğ¾Ñ€ Ğ´Ğ»Ñ readers
    readerCount atomic.Int32  // ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ readers (Ğ¾Ñ‚Ñ€Ğ¸Ñ†Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ = pending writer)
    readerWait  atomic.Int32  // Readers ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ğ¶Ğ´Ñ‘Ñ‚ writer
}

const rwmutexMaxReaders = 1 << 30  // ĞœĞ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ readers
```

### Writer Priority

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    RWMutex Writer Priority                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  readerCount:                                                               â”‚
â”‚  â€¢ ĞŸĞ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ: ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… readers                               â”‚
â”‚  â€¢ ĞÑ‚Ñ€Ğ¸Ñ†Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğµ: ĞµÑÑ‚ÑŒ pending writer (-rwmutexMaxReaders + readers)        â”‚
â”‚                                                                             â”‚
â”‚  Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹: 3 readers, Ğ·Ğ°Ñ‚ĞµĞ¼ Ğ¿Ñ€Ğ¸Ñ…Ğ¾Ğ´Ğ¸Ñ‚ writer                                 â”‚
â”‚                                                                             â”‚
â”‚  1. readerCount = 3  (3 Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… readers)                                   â”‚
â”‚  2. Writer Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Lock()                                                  â”‚
â”‚     readerCount = 3 - rwmutexMaxReaders = -1073741821                       â”‚
â”‚  3. Writer Ğ¶Ğ´Ñ‘Ñ‚ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ 3 readers (readerWait = 3)                       â”‚
â”‚  4. ĞĞ¾Ğ²Ñ‹Ğµ readers Ğ²Ğ¸Ğ´ÑÑ‚ Ğ¾Ñ‚Ñ€Ğ¸Ñ†Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ readerCount â†’ Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒÑÑ‚ÑÑ             â”‚
â”‚  5. ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ reader ÑƒĞ¼ĞµĞ½ÑŒÑˆĞ°ĞµÑ‚ readerWait Ğ´Ğ¾ 0 â†’ Ğ±ÑƒĞ´Ğ¸Ñ‚ writer               â”‚
â”‚  6. Writer Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚                                                         â”‚
â”‚  7. Writer Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Unlock()                                                â”‚
â”‚     readerCount = -1073741821 + rwmutexMaxReaders = 3 blocked readers       â”‚
â”‚  8. Blocked readers Ğ¿Ñ€Ğ¾ÑÑ‹Ğ¿Ğ°ÑÑ‚ÑÑ                                             â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Magic Number -1073741821

```go
// ĞÑ‚ĞºÑƒĞ´Ğ° Ğ±ĞµÑ€Ñ‘Ñ‚ÑÑ ÑÑ‚Ğ¾ Ñ‡Ğ¸ÑĞ»Ğ¾?
const rwmutexMaxReaders = 1 << 30  // 1073741824

// ĞšĞ¾Ğ³Ğ´Ğ° writer Ñ…Ğ¾Ñ‡ĞµÑ‚ Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚Ğ¸Ñ‚ÑŒ lock:
// readerCount.Add(-rwmutexMaxReaders)
// Ğ•ÑĞ»Ğ¸ Ğ±Ñ‹Ğ»Ğ¾ 3 Ñ‡Ğ¸Ñ‚Ğ°Ñ‚ĞµĞ»Ñ: 3 - 1073741824 = -1073741821

// ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ Ğ¸Ğ¼ĞµĞ½Ğ½Ğ¾ 1 << 30?
// 1. Ğ”Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğµ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ Ğ»ÑĞ±Ğ¾Ğµ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ readers
// 2. ĞÑÑ‚Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ¼ĞµÑÑ‚Ğ¾ Ğ´Ğ»Ñ overflow detection (int32 max = 2^31 - 1)
// 3. ĞŸÑ€Ğ¸ ÑĞ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸/Ğ²Ñ‹Ñ‡Ğ¸Ñ‚Ğ°Ğ½Ğ¸Ğ¸ Ğ½Ğµ Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ overflow

// ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ° overflow Ğ² RLock:
func (rw *RWMutex) RLock() {
    if rw.readerCount.Add(1) < 0 {
        // readerCount Ğ¾Ñ‚Ñ€Ğ¸Ñ†Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ â†’ ĞµÑÑ‚ÑŒ pending writer
        // Ğ—Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒÑÑ Ğ½Ğ° readerSem
        runtime_SemacquireRWMutexR(&rw.readerSem, false, 0)
    }
}
```

### RLock/RUnlock

```go
func (rw *RWMutex) RLock() {
    if rw.readerCount.Add(1) < 0 {
        // Writer Ğ¶Ğ´Ñ‘Ñ‚ Ğ¸Ğ»Ğ¸ Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ lock
        runtime_SemacquireRWMutexR(&rw.readerSem, false, 0)
    }
}

func (rw *RWMutex) RUnlock() {
    if r := rw.readerCount.Add(-1); r < 0 {
        // Writer Ğ¶Ğ´Ñ‘Ñ‚
        rw.rUnlockSlow(r)
    }
}

func (rw *RWMutex) rUnlockSlow(r int32) {
    if rw.readerWait.Add(-1) == 0 {
        // ĞŸĞ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ reader â€” Ñ€Ğ°Ğ·Ğ±ÑƒĞ´Ğ¸Ñ‚ÑŒ writer
        runtime_Semrelease(&rw.writerSem, false, 1)
    }
}
```

## sync.WaitGroup

<InteractiveModal title="WaitGroup Simulator" icon="â³" description="Ğ¡Ğ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ sync.WaitGroup Ñ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¸Ğ¼Ğ¸ workers">
  <WaitGroupSimulator />
</InteractiveModal>

### Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°

```go
// sync/waitgroup.go
type WaitGroup struct {
    noCopy noCopy  // go vet Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ° ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ

    state atomic.Uint64  // high 32 bits: counter, low 32 bits: waiters
    sema  uint32         // ÑĞµĞ¼Ğ°Ñ„Ğ¾Ñ€
}
```

### State Encoding

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      WaitGroup State (uint64)                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚       Counter (32 bits)       â”‚       Waiters (32 bits)       â”‚          â”‚
â”‚  â”‚        (Add/Done)             â”‚         (Wait calls)          â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚  MSB                                                             LSB        â”‚
â”‚                                                                             â”‚
â”‚  ĞŸÑ€Ğ¸Ğ¼ĞµÑ€: Add(3), Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼ 2 Wait()                                             â”‚
â”‚  state = 0x0000000300000002  (counter=3, waiters=2)                         â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Add/Done/Wait

```go
func (wg *WaitGroup) Add(delta int) {
    state := wg.state.Add(uint64(delta) << 32)
    v := int32(state >> 32)  // counter
    w := uint32(state)       // waiters

    if v < 0 {
        panic("sync: negative WaitGroup counter")
    }

    if v == 0 && w != 0 {
        // Counter ÑÑ‚Ğ°Ğ» 0, ĞµÑÑ‚ÑŒ waiters â†’ Ñ€Ğ°Ğ·Ğ±ÑƒĞ´Ğ¸Ñ‚ÑŒ Ğ²ÑĞµÑ…
        wg.state.Store(0)
        for ; w != 0; w-- {
            runtime_Semrelease(&wg.sema, false, 0)
        }
    }
}

func (wg *WaitGroup) Done() {
    wg.Add(-1)
}

func (wg *WaitGroup) Wait() {
    for {
        state := wg.state.Load()
        v := int32(state >> 32)
        if v == 0 {
            return  // Counter ÑƒĞ¶Ğµ 0
        }

        // Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ñ‚ÑŒ waiters
        if wg.state.CompareAndSwap(state, state+1) {
            runtime_Semacquire(&wg.sema)
            if wg.state.Load() != 0 {
                panic("sync: WaitGroup is reused before previous Wait returned")
            }
            return
        }
    }
}
```

## sync.Once

### Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°

```go
// sync/once.go
type Once struct {
    done atomic.Uint32  // 1 ĞµÑĞ»Ğ¸ ÑƒĞ¶Ğµ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾
    m    Mutex          // Ğ´Ğ»Ñ slow path
}
```

### Double-Checked Locking

```go
func (o *Once) Do(f func()) {
    // Fast path: ÑƒĞ¶Ğµ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾
    if o.done.Load() == 1 {
        return
    }
    o.doSlow(f)
}

func (o *Once) doSlow(f func()) {
    o.m.Lock()
    defer o.m.Unlock()

    // Double-check Ğ¿Ğ¾Ğ´ lock
    if o.done.Load() == 0 {
        defer o.done.Store(1)
        f()
    }
}
```

### ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ defer Ğ´Ğ»Ñ done.Store?

```go
// Ğ•ÑĞ»Ğ¸ f() Ğ¿Ğ°Ğ½Ğ¸ĞºÑƒĞµÑ‚, done ĞĞ• ÑƒÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµÑ‚ÑÑ
// Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğ¹ Do() ÑĞ½Ğ¾Ğ²Ğ° Ğ¿Ğ¾Ğ¿Ñ‹Ñ‚Ğ°ĞµÑ‚ÑÑ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ f()

var once sync.Once
once.Do(func() {
    panic("oops")  // done Ğ¾ÑÑ‚Ğ°Ñ‘Ñ‚ÑÑ 0
})

once.Do(func() {
    // Ğ‘ÑƒĞ´ĞµÑ‚ Ğ²Ñ‹Ğ·Ğ²Ğ°Ğ½ ÑĞ½Ğ¾Ğ²Ğ°!
})
```

## sync.Cond

### Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°

```go
// sync/cond.go
type Cond struct {
    noCopy  noCopy
    L       Locker      // Ğ’Ğ½ĞµÑˆĞ½Ğ¸Ğ¹ lock (Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾ *Mutex Ğ¸Ğ»Ğ¸ *RWMutex)
    notify  notifyList  // Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ¾Ğ¶Ğ¸Ğ´Ğ°ÑÑ‰Ğ¸Ñ…
    checker copyChecker // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ° ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
}

// runtime/sema.go
type notifyList struct {
    wait   atomic.Uint32  // Ticket Ğ´Ğ»Ñ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ³Ğ¾ waiter
    notify uint32         // Ticket ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ³Ğ¾ Ğ´Ğ»Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ
    lock   mutex          // Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸
    head   *sudog         // Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ° Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸
    tail   *sudog         // Ğ¥Ğ²Ğ¾ÑÑ‚ Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸
}
```

### Wait/Signal/Broadcast

```go
func (c *Cond) Wait() {
    // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ticket
    t := runtime_notifyListAdd(&c.notify)
    c.L.Unlock()

    // Ğ—Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒÑÑ Ğ´Ğ¾ Signal/Broadcast
    runtime_notifyListWait(&c.notify, t)

    c.L.Lock()
}

func (c *Cond) Signal() {
    // Ğ Ğ°Ğ·Ğ±ÑƒĞ´Ğ¸Ñ‚ÑŒ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ waiter
    runtime_notifyListNotifyOne(&c.notify)
}

func (c *Cond) Broadcast() {
    // Ğ Ğ°Ğ·Ğ±ÑƒĞ´Ğ¸Ñ‚ÑŒ Ğ²ÑĞµÑ… waiters
    runtime_notifyListNotifyAll(&c.notify)
}
```

### ĞŸĞ°Ñ‚Ñ‚ĞµÑ€Ğ½ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ

```go
var (
    mu    sync.Mutex
    cond  = sync.NewCond(&mu)
    ready bool
)

// Waiter
mu.Lock()
for !ready {  // Ğ¦Ğ¸ĞºĞ» Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ĞµĞ½!
    cond.Wait()
}
// ... do work ...
mu.Unlock()

// Signaler
mu.Lock()
ready = true
mu.Unlock()
cond.Signal()  // Ğ¸Ğ»Ğ¸ Broadcast()
```

::: warning Ğ¦Ğ¸ĞºĞ» Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ĞµĞ½
`Wait()` Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ ÑĞ¿Ğ¾Ğ½Ñ‚Ğ°Ğ½Ğ½Ğ¾ (spurious wakeup). Ğ’ÑĞµĞ³Ğ´Ğ° Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğµ Ğ² Ñ†Ğ¸ĞºĞ»Ğµ.
:::

### Spurious Wakeup: Ğ¿Ğ¾Ğ´Ñ€Ğ¾Ğ±Ğ½ĞµĞµ

**ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ `Wait()` Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒÑÑ Ğ±ĞµĞ· `Signal()`?**

```go
// 1. OS-level spurious wakeup
//    ĞĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ OS Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ñ€Ğ°Ğ·Ğ±ÑƒĞ´Ğ¸Ñ‚ÑŒ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ñƒ Ğ±ĞµĞ· ÑĞ²Ğ½Ğ¾Ğ³Ğ¾ ÑĞ¸Ğ³Ğ½Ğ°Ğ»Ğ°
//    Ğ­Ñ‚Ğ¾ Ğ¾ÑĞ¾Ğ±ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ futex/semaphore Ñ€ĞµĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸

// 2. Race condition Ğ¿Ñ€Ğ¸ broadcast
//    ĞœĞµĞ¶Ğ´Ñƒ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¾Ğ¹ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ñ Ğ¸ Ğ·Ğ°ÑÑ‹Ğ¿Ğ°Ğ½Ğ¸ĞµĞ¼ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ¾Ğ¹Ñ‚Ğ¸ Signal()
//    Ğ¸ ÑƒÑĞ»Ğ¾Ğ²Ğ¸Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒÑÑ Ğ¾Ğ±Ñ€Ğ°Ñ‚Ğ½Ğ¾

// 3. ĞœĞ½Ğ¾Ğ¶ĞµÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ waiters
//    ĞŸÑ€Ğ¸ Broadcast() Ğ²ÑĞµ Ğ¿Ñ€Ğ¾ÑÑ‹Ğ¿Ğ°ÑÑ‚ÑÑ, Ğ½Ğ¾ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ğ´Ğ¸Ğ½ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ Ñ€ĞµÑÑƒÑ€Ñ
//    ĞÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ ÑĞ½Ğ¾Ğ²Ğ° ÑƒÑĞ½ÑƒÑ‚ÑŒ
```

**ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ Ğ±ĞµĞ· Ñ†Ğ¸ĞºĞ»Ğ°:**

```go
// âŒ ĞĞ•ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ: Ğ±ĞµĞ· Ñ†Ğ¸ĞºĞ»Ğ°
mu.Lock()
if !ready {  // if Ğ²Ğ¼ĞµÑÑ‚Ğ¾ for
    cond.Wait()
}
// ready Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ false Ğ·Ğ´ĞµÑÑŒ Ğ¸Ğ·-Ğ·Ğ° spurious wakeup!
doWork()  // BUG: Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµĞ¼ Ñ Ğ½ĞµĞ³Ğ¾Ñ‚Ğ¾Ğ²Ñ‹Ğ¼Ğ¸ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸
mu.Unlock()

// âœ… ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ: Ñ Ñ†Ğ¸ĞºĞ»Ğ¾Ğ¼
mu.Lock()
for !ready {  // for Ğ²Ğ¼ĞµÑÑ‚Ğ¾ if
    cond.Wait()
}
// ready Ğ³Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾ true
doWork()
mu.Unlock()
```

**ĞŸÑ€Ğ°ĞºÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€ Ñ Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒÑ:**

```go
type Queue struct {
    mu    sync.Mutex
    cond  *sync.Cond
    items []int
}

func NewQueue() *Queue {
    q := &Queue{}
    q.cond = sync.NewCond(&q.mu)
    return q
}

func (q *Queue) Get() int {
    q.mu.Lock()
    defer q.mu.Unlock()

    // Ğ’ĞĞ–ĞĞ: for, Ğ½Ğµ if!
    // Ğ•ÑĞ»Ğ¸ Ğ´Ğ²Ğ° consumer'Ğ° Ğ¿Ñ€Ğ¾ÑĞ½ÑƒĞ»Ğ¸ÑÑŒ Ğ¾Ñ‚ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Signal(),
    // Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚, Ğ²Ñ‚Ğ¾Ñ€Ğ¾Ğ¹ Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ¶Ğ´Ğ°Ñ‚ÑŒ Ğ´Ğ°Ğ»ÑŒÑˆĞµ
    for len(q.items) == 0 {
        q.cond.Wait()
    }

    item := q.items[0]
    q.items = q.items[1:]
    return item
}

func (q *Queue) Put(item int) {
    q.mu.Lock()
    q.items = append(q.items, item)
    q.mu.Unlock()
    q.cond.Signal()  // Ğ Ğ°Ğ·Ğ±ÑƒĞ´Ğ¸Ñ‚ÑŒ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ waiter
}
```

## sync.Pool

### Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°

```go
// sync/pool.go
type Pool struct {
    noCopy noCopy

    local     unsafe.Pointer // [P]poolLocal, per-P pools
    localSize uintptr

    victim     unsafe.Pointer // victim cache Ğ¾Ñ‚ Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰ĞµĞ³Ğ¾ GC
    victimSize uintptr

    New func() any  // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ°
}

type poolLocal struct {
    poolLocalInternal
    pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte // False sharing prevention
}

type poolLocalInternal struct {
    private any       // ĞŸÑ€Ğ¸Ğ²Ğ°Ñ‚Ğ½Ñ‹Ğ¹ Ğ¾Ğ±ÑŠĞµĞºÑ‚ Ğ´Ğ»Ñ P (Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿)
    shared  poolChain // Lock-free Ğ¾Ñ‡ĞµÑ€ĞµĞ´ÑŒ Ğ´Ğ»Ñ sharing
}
```

### Per-P Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        sync.Pool Architecture                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                           Pool                                      â”‚    â”‚
â”‚  â”‚  local: [P0, P1, P2, P3]    victim: [prev GC pools]                 â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚       â”‚                                                                     â”‚
â”‚       â–¼                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ poolLocal  â”‚  â”‚ poolLocal  â”‚  â”‚ poolLocal  â”‚  â”‚ poolLocal  â”‚             â”‚
â”‚  â”‚    P0      â”‚  â”‚    P1      â”‚  â”‚    P2      â”‚  â”‚    P3      â”‚             â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤             â”‚
â”‚  â”‚ private:objâ”‚  â”‚ private:nilâ”‚  â”‚ private:objâ”‚  â”‚ private:nilâ”‚             â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤             â”‚
â”‚  â”‚ shared:    â”‚  â”‚ shared:    â”‚  â”‚ shared:    â”‚  â”‚ shared:    â”‚             â”‚
â”‚  â”‚ [obj,obj]  â”‚  â”‚ [obj]      â”‚  â”‚ []         â”‚  â”‚ [obj,obj]  â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                                             â”‚
â”‚  Get() algorithm:                                                           â”‚
â”‚  1. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²Ğ·ÑÑ‚ÑŒ private ÑĞ²Ğ¾ĞµĞ³Ğ¾ P (lock-free)                          â”‚
â”‚  2. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²Ğ·ÑÑ‚ÑŒ Ğ¸Ğ· shared ÑĞ²Ğ¾ĞµĞ³Ğ¾ P                                    â”‚
â”‚  3. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑƒĞºÑ€Ğ°ÑÑ‚ÑŒ Ğ¸Ğ· shared Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… P                                  â”‚
â”‚  4. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²Ğ·ÑÑ‚ÑŒ Ğ¸Ğ· victim cache                                       â”‚
â”‚  5. Ğ’Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ New()                                                           â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Get/Put

```go
func (p *Pool) Get() any {
    l, pid := p.pin()  // ĞŸÑ€Ğ¸Ğ²ÑĞ·Ğ°Ñ‚ÑŒÑÑ Ğº P, Ğ¾Ñ‚ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ preemption

    // 1. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ private
    x := l.private
    l.private = nil
    if x == nil {
        // 2. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ shared ÑĞ²Ğ¾ĞµĞ³Ğ¾ P
        x, _ = l.shared.popHead()
        if x == nil {
            // 3. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ P Ğ¸Ğ»Ğ¸ victim
            x = p.getSlow(pid)
        }
    }
    runtime_procUnpin()

    if x == nil && p.New != nil {
        x = p.New()
    }
    return x
}

func (p *Pool) Put(x any) {
    if x == nil {
        return
    }

    l, _ := p.pin()

    if l.private == nil {
        l.private = x  // ĞŸĞ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ÑŒ Ğ² private (ÑĞ°Ğ¼Ñ‹Ğ¹ Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ Ğ¿ÑƒÑ‚ÑŒ)
    } else {
        l.shared.pushHead(x)  // ĞŸĞ¾Ğ»Ğ¾Ğ¶Ğ¸Ñ‚ÑŒ Ğ² shared
    }

    runtime_procUnpin()
}

// getSlow Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ ĞºĞ¾Ğ³Ğ´Ğ° private Ğ¸ shared Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ P Ğ¿ÑƒÑÑ‚Ñ‹
func (p *Pool) getSlow(pid int) any {
    size := runtime_LoadAcquintptr(&p.localSize)
    locals := p.local

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° 1: ÑƒĞºÑ€Ğ°ÑÑ‚ÑŒ Ğ¸Ğ· shared Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… P
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    for i := 0; i < int(size); i++ {
        // ĞĞ°Ñ‡Ğ¸Ğ½Ğ°ĞµĞ¼ Ñ pid+1, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ½Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑÑ‚ÑŒ ÑĞµĞ±Ñ ÑĞ½Ğ¾Ğ²Ğ°
        l := indexLocal(locals, (pid+i+1)%int(size))

        // popTail â€” lock-free Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ñ, Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ° Ğ´Ğ»Ñ stealing
        if x, _ := l.shared.popTail(); x != nil {
            return x
        }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ° 2: Ğ²Ğ·ÑÑ‚ÑŒ Ğ¸Ğ· victim cache (Ğ¾Ğ±ÑŠĞµĞºÑ‚Ñ‹ Ğ¾Ñ‚ Ğ¿Ñ€Ğ¾ÑˆĞ»Ğ¾Ğ³Ğ¾ GC)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    size = runtime_LoadAcquintptr(&p.victimSize)
    if uintptr(pid) >= size {
        return nil
    }

    locals = p.victim
    l := indexLocal(locals, pid)

    // Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° private, Ğ¿Ğ¾Ñ‚Ğ¾Ğ¼ shared
    if x := l.private; x != nil {
        l.private = nil
        return x
    }

    for i := 0; i < int(size); i++ {
        l := indexLocal(locals, (pid+i)%int(size))
        if x, _ := l.shared.popTail(); x != nil {
            return x
        }
    }

    // Victim cache Ğ¸ÑÑ‡ĞµÑ€Ğ¿Ğ°Ğ½ Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ P
    runtime_StoreReluintptr(&p.victimSize, 0)
    return nil
}
```

### Victim Cache Ğ¸ GC

```go
// runtime Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ poolCleanup Ğ¿ĞµÑ€ĞµĞ´ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¼ GC
func poolCleanup() {
    // 1. ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ victim cache (objects Ğ¾Ñ‚ Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰ĞµĞ³Ğ¾ GC)
    for _, p := range oldPools {
        p.victim = nil
        p.victimSize = 0
    }

    // 2. ĞŸĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ local â†’ victim
    for _, p := range allPools {
        p.victim = p.local
        p.victimSize = p.localSize
        p.local = nil
        p.localSize = 0
    }
}
```

::: tip Victim Cache
ĞĞ±ÑŠĞµĞºÑ‚Ñ‹ Ğ¶Ğ¸Ğ²ÑƒÑ‚ Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 2 GC Ñ†Ğ¸ĞºĞ»Ğ°:
1. ĞŸĞµÑ€Ğ²Ñ‹Ğ¹ GC: local â†’ victim
2. Ğ’Ñ‚Ğ¾Ñ€Ğ¾Ğ¹ GC: victim Ğ¾Ñ‡Ğ¸Ñ‰Ğ°ĞµÑ‚ÑÑ

Ğ­Ñ‚Ğ¾ Ğ¿Ñ€ĞµĞ´Ğ¾Ñ‚Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ Ğ½Ğ°ĞºĞ¾Ğ¿Ğ»ĞµĞ½Ğ¸Ğµ Ğ¼ÑƒÑĞ¾Ñ€Ğ°, Ğ½Ğ¾ Ğ´Ğ°Ñ‘Ñ‚ ÑˆĞ°Ğ½Ñ Ğ¿ĞµÑ€ĞµĞ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ñ‹.
:::

## sync.Map

### Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°

```go
// sync/map.go
type Map struct {
    mu     Mutex
    read   atomic.Pointer[readOnly]  // read-only ĞºĞ¾Ğ¿Ğ¸Ñ (lock-free Ğ´Ğ¾ÑÑ‚ÑƒĞ¿)
    dirty  map[any]*entry            // dirty ĞºĞ¾Ğ¿Ğ¸Ñ (Ğ¿Ğ¾Ğ´ lock)
    misses int                       // Ğ¿Ñ€Ğ¾Ğ¼Ğ°Ñ…Ğ¸ Ğ¿Ğ¾ read
}

type readOnly struct {
    m       map[any]*entry
    amended bool  // true ĞµÑĞ»Ğ¸ dirty ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ ĞºĞ»ÑÑ‡Ğ¸, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ğ½ĞµÑ‚ Ğ² read
}

type entry struct {
    p atomic.Pointer[any]  // nil, expunged, Ğ¸Ğ»Ğ¸ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğ° Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ
}

// Ğ¡Ğ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ ÑƒĞ´Ğ°Ğ»Ñ‘Ğ½Ğ½Ñ‹Ñ… Ğ¸Ğ· read, Ğ½Ğ¾ ĞµÑ‰Ñ‘ Ğ² dirty
var expunged = new(any)

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚                    Ğ–Ğ¸Ğ·Ğ½ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ†Ğ¸ĞºĞ» entry.p                               â”‚
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
// â”‚                                                                         â”‚
// â”‚   nil          â†’ Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¾, ĞºĞ»ÑÑ‡ ĞµÑ‰Ñ‘ Ğ² dirty                     â”‚
// â”‚   expunged     â†’ Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¾, ĞºĞ»ÑÑ‡Ğ° ĞĞ•Ğ¢ Ğ² dirty                    â”‚
// â”‚   &value       â†’ ĞĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ                                    â”‚
// â”‚                                                                         â”‚
// â”‚   Ğ—Ğ°Ñ‡ĞµĞ¼ Ğ½ÑƒĞ¶ĞµĞ½ expunged?                                                 â”‚
// â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                 â”‚
// â”‚   ĞšĞ¾Ğ³Ğ´Ğ° dirty = nil Ğ¸ Ğ¼Ñ‹ Ñ…Ğ¾Ñ‚Ğ¸Ğ¼ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ dirty:                     â”‚
// â”‚   1. ĞšĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ Ğ²ÑĞµ entry Ğ¸Ğ· read                                         â”‚
// â”‚   2. ĞĞ¾ ĞĞ• ĞºĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ nil entry (Ğ¾Ğ½Ğ¸ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ñ‹)                             â”‚
// â”‚   3. ĞŸĞ¾Ğ¼ĞµÑ‡Ğ°ĞµĞ¼ Ğ¸Ñ… ĞºĞ°Ğº expunged, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹:                                   â”‚
// â”‚      - Load Ğ·Ğ½Ğ°Ğ»: ĞºĞ»ÑÑ‡Ğ° Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ½ĞµÑ‚, Ğ½Ğµ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸ Ğ² dirty                    â”‚
// â”‚      - Store Ğ·Ğ½Ğ°Ğ»: Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ ĞºĞ»ÑÑ‡ Ğ² dirty Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾                   â”‚
// â”‚                                                                         â”‚
// â”‚   ĞŸÑ€Ğ¸Ğ¼ĞµÑ€:                                                               â”‚
// â”‚   1. Store("a", 1)     â†’ read["a"]=&1, dirty["a"]=&1                    â”‚
// â”‚   2. Delete("a")       â†’ read["a"]=nil, dirty["a"]=nil                  â”‚
// â”‚   3. miss++ >= len(dirty) â†’ dirty promote                               â”‚
// â”‚   4. Store("b", 2)     â†’ dirty ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ñ‚ÑÑ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾                         â”‚
// â”‚      read["a"] Ğ¼ĞµĞ½ÑĞµÑ‚ÑÑ nilâ†’expunged (Ğ½Ğµ ĞºĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ² dirty)            â”‚
// â”‚   5. Store("a", 3)     â†’ Ğ²Ğ¸Ğ´Ğ¸Ñ‚ expunged â†’ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµÑ‚ Ğ² dirty             â”‚
// â”‚                                                                         â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Read/Dirty Promotion

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      sync.Map Architecture                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  LOAD (Read-heavy path)                                                     â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                    â”‚
â”‚  1. ĞŸÑ€Ğ¾Ñ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ read atomically                                               â”‚
â”‚  2. Ğ•ÑĞ»Ğ¸ ĞºĞ»ÑÑ‡ ĞµÑÑ‚ÑŒ â†’ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ (Ğ±ĞµĞ· lock!)                                    â”‚
â”‚  3. Ğ•ÑĞ»Ğ¸ amended â†’ Ğ²Ğ·ÑÑ‚ÑŒ lock, Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ dirty                              â”‚
â”‚                                                                             â”‚
â”‚  STORE                                                                      â”‚
â”‚  â•â•â•â•â•                                                                      â”‚
â”‚  1. Ğ•ÑĞ»Ğ¸ ĞºĞ»ÑÑ‡ ĞµÑÑ‚ÑŒ Ğ² read â†’ CAS Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ (Ğ±ĞµĞ· lock!)                        â”‚
â”‚  2. Ğ˜Ğ½Ğ°Ñ‡Ğµ â†’ Ğ²Ğ·ÑÑ‚ÑŒ lock, Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ² dirty                                    â”‚
â”‚                                                                             â”‚
â”‚  PROMOTION (dirty â†’ read)                                                   â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                    â”‚
â”‚  ĞšĞ¾Ğ³Ğ´Ğ° misses >= len(dirty):                                                â”‚
â”‚  1. read = dirty                                                            â”‚
â”‚  2. dirty = nil                                                             â”‚
â”‚  3. misses = 0                                                              â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚  â”‚     read       â”‚                â”‚     dirty      â”‚                       â”‚
â”‚  â”‚ (atomic, fast) â”‚                â”‚ (mutex, slow)  â”‚                       â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                       â”‚
â”‚  â”‚ "key1": val1   â”‚                â”‚ "key1": val1   â”‚                       â”‚
â”‚  â”‚ "key2": val2   â”‚ â”€â”€promotionâ”€â”€â–¶ â”‚ "key2": val2   â”‚                       â”‚
â”‚  â”‚                â”‚                â”‚ "key3": val3   â”‚ â† Ğ½Ğ¾Ğ²Ñ‹Ğµ ĞºĞ»ÑÑ‡Ğ¸         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Load/Store

```go
func (m *Map) Load(key any) (value any, ok bool) {
    read := m.read.Load()
    e, ok := read.m[key]
    if !ok && read.amended {
        m.mu.Lock()
        // Double-check
        read = m.read.Load()
        e, ok = read.m[key]
        if !ok && read.amended {
            e, ok = m.dirty[key]
            m.missLocked()  // Ğ˜Ğ½ĞºÑ€ĞµĞ¼ĞµĞ½Ñ‚ misses, Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ promote
        }
        m.mu.Unlock()
    }
    if !ok {
        return nil, false
    }
    return e.load()
}

func (m *Map) Store(key, value any) {
    read := m.read.Load()
    if e, ok := read.m[key]; ok && e.tryStore(&value) {
        return  // ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ğ»Ğ¸ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¹ ĞºĞ»ÑÑ‡ Ğ±ĞµĞ· lock
    }

    m.mu.Lock()
    read = m.read.Load()
    if e, ok := read.m[key]; ok {
        if e.unexpungeLocked() {
            m.dirty[key] = e
        }
        e.storeLocked(&value)
    } else if e, ok := m.dirty[key]; ok {
        e.storeLocked(&value)
    } else {
        if !read.amended {
            m.dirtyLocked()  // ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ read â†’ dirty
            m.read.Store(&readOnly{m: read.m, amended: true})
        }
        m.dirty[key] = newEntry(value)
    }
    m.mu.Unlock()
}
```

### ĞšĞ¾Ğ³Ğ´Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ sync.Map

| Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹ | sync.Map | map + Mutex |
|----------|----------|-------------|
| Read-heavy (99% reads) | âœ… Ğ›ÑƒÑ‡ÑˆĞµ | ĞĞº |
| Write-heavy | âŒ Ğ¥ÑƒĞ¶Ğµ | âœ… Ğ›ÑƒÑ‡ÑˆĞµ |
| Disjoint keys (Ñ€Ğ°Ğ·Ğ½Ñ‹Ğµ Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ñ‹ Ğ¿Ğ¸ÑˆÑƒÑ‚ Ğ² Ñ€Ğ°Ğ·Ğ½Ñ‹Ğµ ĞºĞ»ÑÑ‡Ğ¸) | âœ… Ğ›ÑƒÑ‡ÑˆĞµ | ĞĞº |
| Ğ§Ğ°ÑÑ‚Ñ‹Ğµ Range() | âŒ ĞšĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµÑ‚ Ğ²ÑÑ‘ | âœ… Ğ‘Ñ‹ÑÑ‚Ñ€ĞµĞµ |
| Ğ˜Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ Ğ½Ğ°Ğ±Ğ¾Ñ€ ĞºĞ»ÑÑ‡ĞµĞ¹ | âŒ Overhead | âœ… ĞŸÑ€Ğ¾Ñ‰Ğµ |

## ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ Ğ¿Ñ€Ğ¸Ğ¼Ğ¸Ñ‚Ğ¸Ğ²Ğ¾Ğ²

```go
// Benchmark Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹ (Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ½Ñ‹Ğµ)
// BenchmarkMutexLock-8         50000000    25 ns/op
// BenchmarkRWMutexRLock-8      100000000   10 ns/op
// BenchmarkRWMutexLock-8       30000000    45 ns/op
// BenchmarkWaitGroupAdd-8      100000000   15 ns/op
// BenchmarkOnce-8              2000000000   0.3 ns/op (Ğ¿Ğ¾ÑĞ»Ğµ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ³Ğ¾)
// BenchmarkPoolGet-8           50000000    30 ns/op
// BenchmarkMapLoad-8           100000000   15 ns/op
```

### Ğ ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¸

1. **Mutex vs RWMutex**: RWMutex Ğ²Ñ‹Ğ³Ğ¾Ğ´ĞµĞ½ Ğ¿Ñ€Ğ¸ >10x reads vs writes
2. **sync.Pool**: Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ»Ñ hot path Ğ°Ğ»Ğ»Ğ¾ĞºĞ°Ñ†Ğ¸Ğ¹ (buffers, temp objects)
3. **sync.Map**: Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ read-heavy + disjoint writes
4. **sync.Once**: Ğ¸Ğ´Ğ¸Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¾ Ğ´Ğ»Ñ lazy initialization
5. **sync.Cond**: Ñ€ĞµĞ´ĞºĞ¾ Ğ½ÑƒĞ¶ĞµĞ½, Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾ channels Ğ»ÑƒÑ‡ÑˆĞµ
